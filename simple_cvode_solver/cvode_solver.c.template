/* 
   THIS IS A GENERATED FILE: PLEASE DO NOT EDIT DIRECTLY.
   
   EDIT THE TEMPLATE INSTEAD.
*/

/* CVODE includes */

#include "cvode.h"
#include <nvector/nvector_serial.h>  /* serial N_Vector types, fcts., macros */
#include <cvode/cvode_dense.h>       /* prototype for CVDense */
#include <sundials/sundials_dense.h> /* definitions DlsMat DENSE_ELEM */
#include <sundials/sundials_types.h> /* definition of type realtype */

/* stdlib, hdf5, local includes */

#include "time.h"
#include "sys/time.h"
#include "stdlib.h"
#include "math.h"
#include "H5LT.h"
#include "rates_and_rate_tables.h"

typedef struct {{ solver_name }}_cvode_data {
    int ncells;
    double *T;
    double *rho;
    double **rates;
    double species_work[{{ species | length }}];
    double reactions_work[{{ reactions | length }}];
    TableOfRates *rate_tables;
} {{ solver_name }}_cvode_data;

/* These change with the particular reaction rate solver, so we do not
outsource them to a header file. */
TableOfRates *{{ solver_name }}_read_rate_tables();
void {{ solver_name }}_interpolate_rates(int nvals, double **outputvals,
        double *inputvals, TableOfRates *rate_tables);
static int {{ solver_name }}_cvode_calc_derivs(
    realtype t, N_Vector y, N_Vector ydot, void *user_data);
static int check_flag(void *flagvalue, char *funcname, int opt);

#ifdef SAMPLE_TEST_PROBLEM
int main(int argc, char** argv)
{
    TableOfRates *my_rates = {{ solver_name }}_read_rate_tables();
    fprintf(stderr, "Successfully read in rate tables.\n");
    /* Now we run some tests.  This is just equally-spaced interpolation. */
    int i, ri, offset = {{ species | length }};

    {{ solver_name }}_cvode_data data;
    my_rates->nrates = {{ reactions | length }};
    data.ncells = 64;
    void *user_data = (void *) &data;

    data.T = (double *) calloc(data.ncells, sizeof(double));
    data.rho = (double *) calloc(data.ncells, sizeof(double));
    data.rates = (double **) calloc(my_rates->nrates, sizeof(double*));
    for (i = 0; i < my_rates->nrates; i++)
        data.rates[i] = (double *) calloc(data.ncells, sizeof(double));

    data.rate_tables = my_rates;

    /* Now boilerplate CVODE stuff */
    realtype reltol, t, tout, abstol;
    N_Vector y;
    void *cvode_mem;
    int flag, flagr, iout;

    y = NULL;
    cvode_mem = NULL;

    /* Create serial vector of length NEQ for I.C. and abstol */
    y = N_VNew_Serial({{ species | length }} * data.ncells);
    if (check_flag((void *)y, "N_VNew_Serial", 0)) return(1);

    {{ initial_conditions }}

    /* Set the scalar relative tolerance */
    reltol = 1e-5; abstol = 0.0;

    /* Call CVodeCreate to create the solver memory and specify the 
     * Backward Differentiation Formula and the use of a Newton iteration */
    cvode_mem = CVodeCreate(CV_BDF, CV_NEWTON);
    if (check_flag((void *)cvode_mem, "CVodeCreate", 0)) return(1);

    /* Call CVodeInit to initialize the integrator memory and specify the
     * user's right hand side function in y'=f(t,y), the inital time T0, and
     * the initial dependent variable vector y. */
    flag = CVodeInit(cvode_mem, {{ solver_name }}_cvode_calc_derivs, 0.0, y);
    if (check_flag(&flag, "CVodeInit", 1)) return(1);

    flag = CVodeSetUserData(cvode_mem, user_data);
    if (check_flag(&flag, "CVodeSetUserData", 1)) return(1);

    /* Call CVodeSVtolerances to specify the scalar relative tolerance
     * and vector absolute tolerances */
    flag = CVodeSStolerances(cvode_mem, reltol, abstol);
    if (check_flag(&flag, "CVodeSVtolerances", 1)) return(1);

    flag = CVodeSetMaxNumSteps(cvode_mem, 10000);
    if (check_flag(&flag, "CVodeSetMaxNumSteps", 1)) return(1);

    /* Call CVDense to specify the CVDENSE dense linear solver */
    //flag = CVDiag(cvode_mem);
    flag = CVDense(cvode_mem, data.ncells * {{ species | length }});
    if (check_flag(&flag, "CVDense", 1)) return(1);

    /* In loop, call CVode, print results, and test for error.
       Break out of loop when NOUT preset output times have been reached.  */
    printf(" \n{{ species | length }}-species kinetics problem\n\n");

    realtype tfinal = 1e14;
    iout = 0;  tout = 1e-3;
    double walli, wallf;
    struct timeval tp;

    gettimeofday(&tp, NULL);
    walli = tp.tv_sec + tp.tv_usec*(1e-6);
    while(1) {
      printf("Requesting output from CVODE at %0.3e (H2I = %0.5e, HI = %0.5e, T = %0.5e)\n",
             tout,
             NV_Ith_S(y, {{ ispecies["H2I"] }}) / data.rho[0],
             NV_Ith_S(y, {{ ispecies["HI"] }}) / data.rho[0],
             NV_Ith_S(y, {{ ispecies["T"] }}));
      flag = CVode(cvode_mem, tout, y, &t, CV_NORMAL);

      if (check_flag(&flag, "CVode", 1)) break;
      if (flag == CV_SUCCESS) {
        iout++;
      }

      if (tout >= tfinal) break;
      tout *= 2.0;
    }
    gettimeofday(&tp, NULL);
    wallf = tp.tv_sec + tp.tv_usec*(1e-6);

    printf("Took %0.5e seconds\n", (wallf-walli));

    /* Free y and abstol vectors */
    N_VDestroy_Serial(y);

    /* Free integrator memory */
    CVodeFree(&cvode_mem);

    return(0);
}
#endif

#ifdef SAMPLE_INTERPOLATE
int main(int argc, char** argv)
{
    TableOfRates *my_rates = {{ solver_name }}_read_rate_tables();
    fprintf(stderr, "Successfully read in rate tables.\n");
    /* Now we run some tests.  This is just equally-spaced interpolation. */
    int i, ri, nvals = 5;
    double **test_output = (double **) calloc(my_rates->nrates, sizeof(double*));
    double *test_input = (double *) calloc(nvals, sizeof(double));
    double db = (log10(my_rates->rates[0].bounds[1]) -
                 log10(my_rates->rates[0].bounds[0]))/(nvals + 1);
    for (i = 0; i < nvals; i++)
    {
        test_input[i] = my_rates->rates[0].bounds[0] * pow(10, db*i);
        fprintf(stderr, "Setting test_input[%i] = %0.8e\n", i, test_input[i]);
    }
    for (i = 0; i < my_rates->nrates; i++)
    {
        test_output[i] = (double *) calloc(nvals, sizeof(double));
    }
    {{ solver_name }}_interpolate_rates(
        nvals, test_output, test_input, my_rates);
    for (i = 0; i < nvals; i++)
    {
        for (ri = 0; ri < my_rates->nrates; ri++)
        {
            fprintf(stderr, "% 5i: % 5i: %0.8e\n", i, ri, test_output[ri][i]);
        }
    }
    return 0;
}
#endif

TableOfRates *{{ solver_name }}_read_rate_tables()
{
    TableOfRates *chemical_rates = 
            (TableOfRates *) malloc(sizeof(TableOfRates));

    herr_t status;
    hid_t file_id = H5Fopen("{{ solver_name }}_rate_tables.h5", H5F_ACC_RDONLY, H5P_DEFAULT);
    /* Allocate the correct number of rate tables */
    hsize_t dims;

    chemical_rates->nrates = {{ rate_table|length }};
    chemical_rates->rates =
            (RateTable *) malloc(sizeof(RateTable) * chemical_rates->nrates);

    int i = 0;

    RateTable *crate;

    {%- for name, rate in rate_table|dictsort %}
    /* Now reading our {{ rate.rate_id }}-th rate, {{ rate.name }} */
    status = H5LTget_dataset_info(file_id, "/{{ rate.name }}", &dims, NULL, NULL);
    crate = &chemical_rates->rates[{{ rate.rate_id }}];
    /* Assume log-spaced bins */
    crate->bounds[0] = {{ rate.T_bounds[0] }};
    crate->bounds[1] = {{ rate.T_bounds[1] }};
    crate->nbins = {{ rate.T | length }};
    crate->dbin = (log10(crate->bounds[1]) - log10(crate->bounds[0])) / crate->nbins;
    crate->idbin = 1.0L / crate->dbin;
    crate->values = (double *) malloc(crate->nbins * sizeof(double));
    H5LTread_dataset_double(file_id, "/{{ rate.name }}", crate->values);
    i++;
    {%- endfor %}

    return chemical_rates;
}

/*
   This setup may be different than the user may anticipate, as a result
   of the lockstep timestep we use for a pencil beam through the grid.
   As such, it accepts the number of things to interpolate and makes
   assumptions about the sizes of the rates.
*/


/* This also requires no templating other than for the solver name...*/
void {{ solver_name }}_interpolate_rates(int nvals, double **outputvals, double *inputvals,
                       TableOfRates *rate_tables)
{
    /* TODO: Change bounds of all rates to be universal -- calculate outside
       the loop the indices into the rate tables */

    int i, ri, bin_id;
    RateTable *crate;
    double *log_input = calloc(nvals, sizeof(double));
    double dd, bv, dy, lb, ub;
    for (i = 0; i < nvals; i++) log_input[i] = log10(inputvals[i]);

    for (ri = 0; ri < rate_tables->nrates; ri++) {
        crate = &rate_tables->rates[ri];
        lb = log10(crate->bounds[0]);
        ub = log10(crate->bounds[1]);
        for (i = 0; i < nvals; i++) {
            /* Our interpolation logic here */
            /* Identify our bin */
            bin_id = (int) (crate->idbin * (log_input[i] - lb));
            dd = log_input[i] - (bin_id * crate->dbin + lb);
            bv = crate->values[bin_id];
            dy = crate->values[bin_id + 1] - bv;
            outputvals[ri][i] = bv + dd*dy*crate->idbin;
            /*fprintf(stdout, "AUGH %i %0.5e %0.5e %0.5e\n",
                    bin_id, crate->idbin, log_input[i], lb);*/
        }
    }
}

void {{ solver_name }}_cvode_calculate_temperature(
    double *Tout, N_Vector y, int ncells, int offset)
{
    int cell;
    for (cell = 0; cell < ncells; cell++ )
    {
      Tout[cell] = NV_Ith_S(y, {{ ispecies["T"] }} + offset*cell);
      //printf("T: %i = %0.3e\n", cell, Tout[cell]);
    }
}

static int {{ solver_name }}_cvode_calc_derivs(
    realtype t, N_Vector y, N_Vector ydot, void *user_data)
{
  /* Psuedocode for calculating:
      calculate our T
      interpolate our k values at their T 
      for cell in cells:
          for rxn in rxns:
              calculate r from species and k values
          for s in species:
              for rxn in rxns:
                  if s not in rxn.considered: continue
                  ydot(s) += rxn.dot(species)
          calculate cooling
          ydot(ge) += cooling
  */

  int i, cell, offset;
  /* We calculate our offset between identical species for different cells */
  int species_offset = {{ species | length }};

  /* Now we have our user_data object. */
  {{ solver_name }}_cvode_data *data = ({{ solver_name }}_cvode_data *) user_data;

  /* This function calculates the temperature and stores it in a member of the
  data object */

  /* Note that we use the name 'cvode' here because it needs to understand the
  cvode vector setup as well as the offset information */
  {{ solver_name }}_cvode_calculate_temperature( data->T, y, data->ncells,
                        species_offset );
  {{ solver_name }}_interpolate_rates( data->ncells, data->rates, data->T,
                                       data->rate_tables);

  /*printf("T %0.5e r21 %0.5e\n", data->T[0], data->rates[{{ ireactions["r21"] }}][0]);*/

  for (cell = 0, offset = 0; cell < data->ncells; cell += 1, offset += species_offset)
  {
    /*
      We fundamentally calculate cooling differently than chemical kinetic
      equations, but note that above we also carry our 'species' that is gas
      energy; we simply have no chemical rate equations that depend on it.
    */
    for (i = 0; i < {{ species | length }}; i++)
    {
        data->species_work[i] = NV_Ith_S(y, i + offset);
    }
    {%- for rname, rxn in reactions|dictsort %}  
    /* Calculating reaction value for {{ rxn.name }} */
    data->reactions_work[{{ rxn.reaction_id }}] = data->rates[{{ rxn.reaction_id }}][cell] *
        {{ rxn.print_c_reaction_value( "data->species_work[%s]") }} ;

    {%- endfor %}

    /* TODO: CHECK THIS WITH THE WEIGHTING */
    {%- for sname, s in species|dictsort %}
      /*
         Handling species {{ sname }}
      */

      NV_Ith_S(ydot, {{ s.species_id }} + offset) = {{ s.weight }} * (
        0.0 
      {%- for rname, rxn in reactions|dictsort %}
        {%- if sname in rxn.considered %}
        /* REACTION: {{ rxn.name }}
           {{ rxn }}
           DOWN: {{ rxn.down_species }}
           UP  : {{ rxn.up_species }} */
        {%- for nchange, s1 in rxn.right_side %}
          {% if s1.name == s.name %}
          /* Contribution from right side */
          +{{nchange|float}} * data->reactions_work[{{ rxn.reaction_id }}]
          {%- endif %}
        {%- endfor %}
        {%- for nchange, s1 in rxn.left_side %}
          {% if s1.name == s.name %}
          /* Contribution from left side */
          -{{nchange|float}} * data->reactions_work[{{ rxn.reaction_id }}]
          {%- endif %}
        {%- endfor %}
        {%- endif %}
      {%- endfor %}
      );
#ifdef {{ solver_name }}_CVODE_DEBUG
    printf("  cell = % 4i species = % 7s val = %0.5e dot = % 0.5e\n",
           cell, "{{ sname }}",
           NV_Ith_S(y   , {{ s.species_id }} + offset),
           NV_Ith_S(ydot, {{ s.species_id }} + offset));
#endif
    {%- endfor %}

    NV_Ith_S(ydot, {{ ispecies["T"] }} + offset) += 
        (0.5 / data->rho[cell]) * 52000.0 * NV_Ith_S(ydot, {{ ispecies["H2I"] }});

  }

  return (0);

}

static int check_flag(void *flagvalue, char *funcname, int opt)
{
  int *errflag;

  /* Check if SUNDIALS function returned NULL pointer - no memory allocated */
  if (opt == 0 && flagvalue == NULL) {
    fprintf(stderr, "\nSUNDIALS_ERROR: %s() failed - returned NULL pointer\n\n",
	    funcname);
    return(1); }

  /* Check if flag < 0 */
  else if (opt == 1) {
    errflag = (int *) flagvalue;
    if (*errflag < 0) {
      fprintf(stderr, "\nSUNDIALS_ERROR: %s() failed with flag = %d\n\n",
	      funcname, *errflag);
      return(1); }}

  /* Check if function returned NULL pointer - no memory allocated */
  else if (opt == 2 && flagvalue == NULL) {
    fprintf(stderr, "\nMEMORY_ERROR: %s() failed - returned NULL pointer\n\n",
	    funcname);
    return(1); }

  return(0);
}
