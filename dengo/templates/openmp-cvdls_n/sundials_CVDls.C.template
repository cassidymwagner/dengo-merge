{% block solver_comment_header %}
/* THIS FILE HAS BEEN AUTO-GENERATED.  DO NOT EDIT. */

/* This is C++ code to read HDF5 files for
   reaction rates, cooling rates, and initial
   conditions for the chemical network defined
   by the user.  In addition, this contains
   code for calculating temperature from the
   gas energy and computing the RHS and the
   Jacobian of the system of equations which
   will be fed into the solver.
*/
{% endblock %}

#include "{{solver_name}}_solver.h"

void *setup_cvode_solver( rhs_f f, jac_f Jac, double abstol , int , 
        {{solver_name}}_data *data, SUNLinearSolver , SUNMatrix , N_Vector );
int cvode_solver( void *cvode_mem, double *output, int NEQ, double *dt, {{solver_name}}_data * data, N_Vector y);

{{solver_name}}_data *{{solver_name}}_setup_data(
    int *NumberOfFields, char ***FieldNames)
{
    int i;

    {{solver_name}}_data *data = ({{solver_name}}_data *) malloc(sizeof({{solver_name}}_data));
    
    /* allocate space for the scale related pieces */
    for (int n = 0; n < omp_get_max_threads(); n++){
        for (i = 0; i< {{network.required_species | length}} ; i++){
            data->scale[n][i] = 1.0;
            data->inv_scale[n][i] = 1.0;
            }

        data->Ts[n]    = 1000.0;
        data->logTs[n] = 1000.0;
        }
    
    /*initialize temperature so it wont crash*/

    /* Temperature-related pieces */
    data->bounds[0] = {{ network.T_bounds[0] }};
    data->bounds[1] = {{ network.T_bounds[1] }};
    data->nbins = {{ network.T | length }} - 1;
    data->dbin = (log(data->bounds[1]) - log(data->bounds[0])) / data->nbins;
    data->idbin = 1.0L / data->dbin;

    /* Redshift-related pieces */
    data->z_bounds[0] = {{ network.z_bounds[0] }};
    data->z_bounds[1] = {{ network.z_bounds[1] }};
    data->n_zbins = {{ network.z | length }} - 1;
    data->d_zbin = (log(data->z_bounds[1] + 1.0) - log(data->z_bounds[0] + 1.0)) / data->n_zbins;
    data->id_zbin = 1.0L / data->d_zbin;
    
    {{ solver_name }}_read_rate_tables(data);
    fprintf(stderr, "Successfully read in rate tables.\n");

    {{ solver_name }}_read_cooling_tables(data);
    fprintf(stderr, "Successfully read in cooling rate tables.\n");
    
    {{ solver_name }}_read_gamma(data);
    fprintf(stderr, "Successfully read in gamma tables. \n");

    if (FieldNames != NULL && NumberOfFields != NULL) {
        NumberOfFields[0] = {{network.required_species | length}};
        FieldNames[0] = new char*[{{ network.required_species | length }}];
        i = 0;
        {% for s in network.required_species | sort %}
        FieldNames[0][i++] = strdup("{{s.name}}");
        {% endfor %}
    }
    return data;

}

{% block entry_point %}
int {{solver_name}}_main(int argc, char** argv)
{
    {{ solver_name }}_data *data = {{solver_name}}_setup_data(NULL, NULL);

    /* Initial conditions */

    hid_t file_id = H5Fopen("{{ solver_name }}_initial_conditions.h5", H5F_ACC_RDONLY, H5P_DEFAULT);
    if (file_id < 0) {fprintf(stderr, "Failed to open "
        "{{ solver_name }}_initial_conditions.h5 so dying.\n");
        return(1);}

    /* Allocate the correct number of cells */
    hsize_t dims; /* We have flat versus number of species */

    /* Check gas energy to get the number of cells */
    fprintf(stderr, "Getting dimensionality from {{ network.energy_term.name }}:\n");
    herr_t status = H5LTget_dataset_info(file_id, "/{{ network.energy_term.name }}", &dims, NULL, NULL);
    if(status == -1) {
        fprintf(stderr, "Error opening initial conditions file.\n");
        return 1;
    }
    fprintf(stderr, "  ncells = % 3i\n", (int) dims);
    data->ncells = dims;

    int N = {{network.required_species | length}};

    double *atol, *rtol;
    atol = (double *) malloc(N * dims * sizeof(double));
    rtol = (double *) malloc(N * dims * sizeof(double));

    double *tics = (double *) malloc(dims * sizeof(double));
    double *ics = (double *) malloc(dims * N * sizeof(double));
    double *input = (double *) malloc(dims * N * sizeof(double));
    
    unsigned int i = 0, j;
    {% for s in network.required_species | sort %}
    fprintf(stderr, "Reading I.C. for /{{ s.name }}\n");
    H5LTread_dataset_double(file_id, "/{{ s.name }}", tics);
    for (j = 0; j < dims; j++) {
        ics[j * N + i] = tics[j]; 
        atol[j * N + i] = tics[j] * 1e-09;
        rtol[j * N + i] = 1e-09;
        if(j==0) {
            fprintf(stderr, "{{s.name}}[0] = %0.3g, atol => % 0.16g\n",
                    tics[j], atol[j]);
        }
    }
    i++;
    {% endfor %}

    H5Fclose(file_id);

    double dtf = {{ network.stop_time }};
    double dt = -1.0;
    double z = -1.0;
    for (i = 0; i < dims * N; i++) input[i] = ics[i];
    double ttot;
    ttot = dengo_evolve_{{solver_name}}(dtf, dt, z, input, rtol, atol, dims, data);

    /* Write results to HDF5 file */
    file_id = H5Fcreate("{{ solver_name }}_solution.h5", H5F_ACC_TRUNC, H5P_DEFAULT, H5P_DEFAULT);
    hsize_t dimsarr[1];
    dimsarr[0] = dims;
    i = 0;
    {% for s in network.required_species | sort %}
    double {{ s.name }}[dims];
    for (j = 0; j < dims; j++) {
        {{ s.name }}[j] = input[j * N + i]; 
    }
    fprintf(stderr, "Writing solution for /{{ s.name }}\n");
    H5LTmake_dataset_double(file_id, "/{{ s.name }}", 1, dimsarr, {{ s.name }});
    i++;
    {% endfor %}
    double temperature[dims];
    for (j = 0; j < dims; j++) {
    	temperature[j] = data->Ts[j];
    }
    H5LTmake_dataset_double(file_id, "/T", 1, dimsarr, temperature);
    double time[1];
    time[0] = ttot;
    double timestep[1];
    timestep[0] = dt;
    H5LTset_attribute_double(file_id, "/", "time", time, 1); 
    H5LTset_attribute_double(file_id, "/", "timestep", timestep, 1);
    H5Fclose(file_id);
    
    return 0;
}
{% endblock %} {# entry_point #}

{% block main_evolution %}

double dengo_evolve_{{solver_name}} (double dtf, double &dt, double z, double *input,
            double *rtol, double *atol, long long dims, {{solver_name}}_data *data) {
    int i, j;
    hid_t file_id;
    /* fprintf(stderr, "  ncells = % 3i\n", (int) dims); */

    int N = {{network.required_species | length}};

    
    {%- if not network.input_is_number %}
    for (i = 0; i<dims; i++) {
      j = i * N;
      {%- for species in network.required_species | sort %}
        {%if species.name != "ge" %}
          input[j] /= {{species.weight}};
          atol[j] /= {{species.weight}};
        {%endif%}
        j++;
      {%endfor%}
    }
    {%- endif %}

    rhs_f f = calculate_rhs_{{solver_name}};
    jac_f jf = calculate_jacobian_{{solver_name}};
    if (dt < 0) dt = dtf / 1e0;
    data->current_z = z;
    int niter = 0;
    int siter = 0;

    // Initialize a CVODE object, memory space for EACH THREAD
    // and attach rhs, jac to them respectively.

    int flag;
    double abstol = 1.0e-6;
    void *cvode_mem;
    int MAX_ITERATION = 1;
    double y[10]; // pass answer back from the solver
    double floor_value = 1e-25;
    
    // cvode objects
    SUNLinearSolver LS;
    SUNMatrix A;
    N_Vector y_vec;
    
    y_vec = NULL;
    LS    = NULL;
    A     = NULL;

    y_vec = N_VNew_Serial(N);
    for (i=0; i<N; i++) {
        NV_Ith_S(y_vec,i)   = 1.0;
        y[i] = 1.0;
    }
    
    // these objects should be initialize once !!
    // in each separate thread!!



    double *internal_dt = (double *) malloc(dims * sizeof(double));
    double *ttot = (double *) malloc(dims * sizeof(double));
    int d;
    int sum;
    

    int omp_get_thread_num();
    int threadID;

    #pragma omp parallel private (A, LS, cvode_mem, threadID, y_vec)
    {
        y_vec = NULL;
        y_vec = N_VNew_Serial(N);
        for ( i = 0; i < N; i++){
            NV_Ith_S(y_vec , i) = 1.0;
            y[i]                = 1.0;
            
        }
    A = SUNDenseMatrix(N, N);
    LS = SUNDenseLinearSolver(y_vec, A);
    cvode_mem = setup_cvode_solver( f, jf, abstol, N, data, LS, A, y_vec);

    #pragma omp for private (sum, i, d, siter, y)
    for (int d = 0; d < dims; d++){
        
        threadID = omp_get_thread_num();
        // copy array which can be passed to the solver
        for (i = 0; i < N; i++){ 
            // this is being passed around 
            // passively by the "dengo_rate_data" 
            // will have to fix it for openmp
            data->scale[threadID][i]     = input[d*N + i];
            data->inv_scale[threadID][i] = 1.0 / input[d*N + i];
        }
        
        // initialize a dt for the solver    
        internal_dt[d] = dt;
        ttot[d]        = 0.0;
        siter          = 0;
            
        while (ttot[d] < dtf) { 
            flag = cvode_solver( cvode_mem, y, N, &internal_dt[d], data, y_vec);
            
            fprintf(stderr, "%d th strip: %d iterations, internal_dt : %0.5g\n", d, siter, internal_dt[d] );

            for (i = 0; i < N; i++) {
                if (y[i] < 0) {
                    flag = 1;
                    break;
                }
            }

            if (flag < 1){
                for (i = 0; i < N; i++){
                    data->scale[threadID][i] = y[i] * data->scale[threadID][i];
                    data->inv_scale[threadID][i] = 1.0/ data->scale[threadID][i];
                    fprintf(stderr , "data->scale[%d] = %0.5g \n", i,y[i]);
                }

                ttot[d] += internal_dt[d];

            } else{
                internal_dt[d] /= 2.0;
            }

	        internal_dt[d] = DMIN(internal_dt[d] * 1.1, dtf - ttot[d] );

            if (siter == MAX_ITERATION) break;

        
            siter++;
        } // while loop for each strip
        
        //fprintf(stderr, "%d the strip = %0.5g\n", d, ttot);

        for (i = 0; i < N; i++){
            input[d*N +i] = data->scale[threadID][i] ;
        } // copy data back to the input array
        fprintf(stderr, "%d the strip = %0.5g\n", d, ttot[d]);

    } // for d dims loop
    
    
    CVodeFree(&cvode_mem);
    SUNLinSolFree(LS);
    SUNMatDestroy(A);
    N_VDestroy(y_vec);
    
    }
    free(data);

    {%-  if not network.input_is_number %}
    for (i = 0; i<dims; i++) {
      j = i * N;
      {%- for species in network.required_species | sort %}
        {%if species.name != "ge" %}
          input[j] *= {{species.weight}} ;
          atol[j] *= {{species.weight}} ;
        {%endif%}
        j++;
      {%endfor%}
    }
    {%- endif %}

    double min_dt = dtf;
    for (d = 0; d < dims; d++){
        if (ttot[d] < min_dt) {
            min_dt = ttot[d];
        }
    }

    return min_dt;
}
{% endblock %} {# main_evolution #}

{% block read_tables %}
void {{ solver_name }}_read_rate_tables({{solver_name}}_data *data)
{
    hid_t file_id = H5Fopen("{{ solver_name }}_tables.h5", H5F_ACC_RDONLY, H5P_DEFAULT);
    /* Allocate the correct number of rate tables */

    {%- for name, rate in network.reactions | dictsort %}
    H5LTread_dataset_double(file_id, "/{{ name }}", data->r_{{name}});
    {%- endfor %}

    H5Fclose(file_id);
}

void {{ solver_name }}_read_cooling_tables({{solver_name}}_data *data)
{

    hid_t file_id = H5Fopen("{{ solver_name }}_tables.h5", H5F_ACC_RDONLY, H5P_DEFAULT);
    /* Allocate the correct number of rate tables */

    {%- for name, rate in network.cooling_actions | dictsort %}
    {%- for name2 in rate.tables | sort %}
    H5LTread_dataset_double(file_id, "/{{name}}_{{name2}}",
                            data->c_{{name}}_{{name2}});
    {%- endfor %}
    {%- endfor %}

    H5Fclose(file_id);
}

void {{ solver_name }}_read_gamma({{solver_name}}_data *data)
{

    hid_t file_id = H5Fopen("{{ solver_name }}_tables.h5", H5F_ACC_RDONLY, H5P_DEFAULT);
    /* Allocate the correct number of rate tables */
    

    {%- for sp in network.interpolate_gamma_species_name | sort %}
    H5LTread_dataset_double(file_id, "/gamma{{sp}}",
                            data->g_gamma{{sp}} );
    H5LTread_dataset_double(file_id, "/dgamma{{sp}}_dT",
                            data->g_dgamma{{sp}}_dT );   
    {% endfor %}

    H5Fclose(file_id);

}
{% endblock %} {# read_tables #}

{% block calculate_temperature %}
void {{ solver_name }}_calculate_temperature({{ solver_name }}_data *data,
                        double *input, int nstrip, int nchem)
{
    int i, j;
    double density;
    double kb = 1.3806504e-16; // Boltzmann constant [erg/K]
    double mh = 1.67e-24;
    double gamma = 5.e0/3.e0;
    
    {% if 'H2_1' in network.species_list() %}
    double gammaH2 = 7.e0/5.e0; // Should be a function of temperature
    	   	     		// this is a temporary solution
    double T,x, expx, Tnew;
    {% endif %}
    
    int omp_get_thread_num();
    int threadID = omp_get_thread_num();
    
    
    /* Calculate total density */

    {%- for species in network.required_species | sort %}
    double {{species.name}};
    {%- endfor %}
    
    /* define scale */
    double scale;

    j = 0;
    {%- for species in network.required_species | sort %}
    scale = data->scale[threadID][j];
    {{species.name}} = input[j]*scale;
    j++;
    {% endfor %}
    density = {{network.print_mass_density()}};
        
    
    {% if 'H2_1' in network.species_list() %}
    
    i = threadID;
    // Initiate the "guess" temperature
    T = data->Ts[i];
    Tnew = T + 1.0;
    double dge_dT;
    double dge;

    {% for sp in network.interpolate_gamma_species_name | sort %}
    double gamma{{sp}};
    double dgamma{{sp}}_dT;
    {% endfor %}
    
    double Tdiff = fabs(Tnew - T);

    while (Tdiff > 0.1 ){
        // We do Newton's Iteration to calculate the temperature
        // Since gammaH2 is dependent on the temperature too!
        T = data->Ts[i];
    
        {{ solver_name }}_interpolate_gamma(data, i);
        {% for sp in network.interpolate_gamma_species_name | sort %}
        gamma{{sp}} = data->gamma{{sp}}[i];
        dgamma{{sp}}_dT = data->dgamma{{sp}}_dT[i];
        // fprintf(stderr, ":gamma{{sp}} %0.5g , dgamma{{sp}}_dT: %.5g \n", gamma{{sp}}, dgamma{{sp}}_dT  );
        {% endfor %}
       
        
        // update gammaH2

        {#
        x = 6100.0 / T;
        expx = exp(x);
        gammaH2 = 2.0 / (5.0 + 2.0 *x*x* expx/ (expx - 1.0) / (expx - 1.0) ) + 1.0;
        {% for sp in network.interpolate_gamma_species_name | sort %}
        gamma{{sp}} = gammaH2;
        dgamma{{sp}}_dT = 0.0;
        {% endfor %}
        #}

        // The derivatives of  sum (nkT/(gamma - 1)/mh/density) - ge
        // This is the function we want to minimize
        // which should only be dependent on the first part
        dge_dT = {{network.temperature_calculation(derivative_dge_dT=True)}};
        
        //This is the change in ge for each iteration
        dge = {{network.temperature_calculation(get_dge=True)}};

        Tnew = T - dge/dge_dT;
        data->Ts[i] = Tnew;
        
        Tdiff = fabs(T - Tnew);
        // fprintf(stderr, "from thread: %d: T: %0.5g ; Tnew: %0.5g; dge_dT: %.5g, dge: %.5g, ge: %.5g \n",threadID, T,Tnew, dge_dT, dge, ge);

        }
        // fprintf(stderr,"---------------------\n");
        data->Ts[i] = Tnew;


        // fprintf(stderr,"T : %0.5g, density : %0.5g, d_gammaH2: %0.5g \n", Tnew, density, gammaH2 - 7./5.);


        {% else %}
        data->Ts[i] = {{network.temperature_calculation()}};
        {% endif %}

        if (data->Ts[i] < data->bounds[0]) {
            data->Ts[i] = data->bounds[0];
        } else if (data->Ts[i] > data->bounds[1]) {
            data->Ts[i] = data->bounds[1];
        }
        data->logTs[i] = log(data->Ts[i]);
        data->invTs[i] = 1.0 / data->Ts[i];
	    data->dTs_{{ network.energy_term.name }}[i] = 
        {{ network.temperature_calculation(derivative=True) }};
        /*fprintf(stderr, "T[%d] = % 0.16g, density = % 0.16g\n",
                i, data->Ts[i], density);*/
    }
         
{% endblock %} {# calculate_temperature #}

{% block interpolate_rates %}
/*
   This setup may be different than the user may anticipate, as a result
   of the lockstep timestep we use for a pencil beam through the grid.
   As such, it accepts the number of things to interpolate and makes
   assumptions about the sizes of the rates.
*/

/* This also requires no templating other than for the solver name...*/
void {{ solver_name }}_interpolate_rates({{ solver_name }}_data *data,
                    int nstrip)
{
    int i, bin_id, zbin_id;
    double lb, t1, t2;
    double lbz, z1, z2;
    int no_photo = 0;
    lb = log(data->bounds[0]);
    lbz = log(data->z_bounds[0] + 1.0);
    /*fprintf(stderr, "lb = % 0.16g, ub = % 0.16g\n", lb, ub);*/
    
    int omp_get_thread_num();
    i = omp_get_thread_num();

    data->bin_id[i] = bin_id = (int) (data->idbin * (data->logTs[i] - lb));
    if (data->bin_id[i] <= 0) {
        data->bin_id[i] = 0;
    } else if (data->bin_id[i] >= data->nbins) {
        data->bin_id[i] = data->nbins - 1;
    }
    t1 = (lb + (bin_id    ) * data->dbin);
    t2 = (lb + (bin_id + 1) * data->dbin);
    data->Tdef[i] = (data->logTs[i] - t1)/(t2 - t1);
    data->dT[i] = (t2 - t1);
    /*fprintf(stderr, "INTERP: %d, bin_id = %d, dT = % 0.16g, T = % 0.16g, logT = % 0.16g\n",
                i, data->bin_id[i], data->dT[i], data->Ts[i],
                data->logTs[i]);*/
    
    if ((data->current_z >= data->z_bounds[0]) && (data->current_z < data->z_bounds[1])) {
        zbin_id = (int) (data->id_zbin * (log(data->current_z + 1.0) - lbz));
        if (zbin_id <= 0) {
            zbin_id = 0;
        } else if (zbin_id >= data->n_zbins) {
            zbin_id = data->n_zbins - 1;
        }
        z1 = (lbz + (zbin_id    ) * data->d_zbin);
        z2 = (lbz + (zbin_id + 1) * data->d_zbin);
        data->zdef = (log(data->current_z + 1.0) - z1)/(z2 - z1);
        data->dz = (exp(z2) - exp(z1)); //note: given this, we don't have to divide rate of change by z
    } else {
        no_photo = 1;
    }
    {% for name, rate in network.reactions | dictsort %}
    {%- if 'pi' not in name %}
        
    bin_id = data->bin_id[i];
    data->rs_{{name}}[i] = data->r_{{name}}[bin_id] +
    data->Tdef[i] * (data->r_{{name}}[bin_id+1] - data->r_{{name}}[bin_id]);
    data->drs_{{name}}[i] = (data->r_{{name}}[bin_id+1] - data->r_{{name}}[bin_id]);
    data->drs_{{name}}[i] /= data->dT[i];
	data->drs_{{name}}[i] *= data->invTs[i];
    
    {% else %}
    if (no_photo) {
        data->rs_{{name}}[i] = 0.0;
        data->drs_{{name}}[i] = 0.0;
    } else {
        data->rs_{{name}}[i] = data->r_{{name}}[zbin_id] +
        data->zdef * (data->r_{{name}}[zbin_id+1] - data->r_{{name}}[zbin_id]);
        data->drs_{{name}}[i] = (data->r_{{name}}[zbin_id+1] - data->r_{{name}}[zbin_id]);
        data->drs_{{name}}[i] /= data->dz;
        }
        /*fprintf(stderr, "data->rs_{{name}} = %0.3e ; data->drs_{{name}} = %0.3e\n",
                data->rs_{{name}}[i], data->drs_{{name}}[i]);*/
    
    {% endif -%}
    {% endfor %}
    {%- for name, rate in network.cooling_actions | dictsort %}
    {%- for name2 in rate.tables | sort %}
    {%- if 'ph' not in name %}
        
    bin_id = data->bin_id[i];
    data->cs_{{name}}_{{name2}}[i] = data->c_{{name}}_{{name2}}[bin_id] +
            data->Tdef[i] * (data->c_{{name}}_{{name2}}[bin_id+1] - data->c_{{name}}_{{name2}}[bin_id]);
    data->dcs_{{name}}_{{name2}}[i] = (data->c_{{name}}_{{name2}}[bin_id+1] - data->c_{{name}}_{{name2}}[bin_id]);;
    data->dcs_{{name}}_{{name2}}[i] /= data->dT[i];
	data->dcs_{{name}}_{{name2}}[i] *= data->invTs[i];
    
    {%- else %}
    if (no_photo) {
        data->cs_{{name}}_{{name2}}[i] = 0.0;
        data->dcs_{{name}}_{{name2}}[i] = 0.0;
    } else {
        data->cs_{{name}}_{{name2}}[i] = data->c_{{name}}_{{name2}}[zbin_id] +
        data->zdef * (data->c_{{name}}_{{name2}}[zbin_id+1] - data->c_{{name}}_{{name2}}[zbin_id]);
        data->dcs_{{name}}_{{name2}}[i] = (data->c_{{name}}_{{name2}}[zbin_id+1] - data->c_{{name}}_{{name2}}[zbin_id]);;
        data->dcs_{{name}}_{{name2}}[i] /= data->dz;
    }
    
    {%- endif -%}          
    {% endfor %}
    {% endfor %}

}
{% endblock %} {# interpolate_rates #}

{% block interpolate_gamma %}
void {{ solver_name }}_interpolate_gamma({{ solver_name }}_data *data,
                    int i)
{   

    /*
     * find the bin_id for the given temperature 
     * update dT for i_th strip
     */

    int bin_id, zbin_id;
    double lb, t1, t2;
    double lbz, z1, z2;
    int no_photo = 0;
    lb = log(data->bounds[0]);
    lbz = log(data->z_bounds[0] + 1.0);
    
    int omp_get_thread_num();
    i = omp_get_thread_num();

    data->bin_id[i] = bin_id = (int) (data->idbin * (data->logTs[i] - lb));
    if (data->bin_id[i] <= 0) {
        data->bin_id[i] = 0;
    } else if (data->bin_id[i] >= data->nbins) {
        data->bin_id[i] = data->nbins - 1;
    }
    t1 = (lb + (bin_id    ) * data->dbin);
    t2 = (lb + (bin_id + 1) * data->dbin);
    data->Tdef[i] = (data->logTs[i] - t1)/(t2 - t1);
    data->dT[i] = (t2 - t1);

    {% for sp in network.interpolate_gamma_species_name%}
    
    bin_id = data->bin_id[i];
    data->gamma{{sp}}[i] = data->g_gamma{{sp}}[bin_id] +
        data->Tdef[i] * (data->g_gamma{{sp}}[bin_id+1] - data->g_gamma{{sp}}[bin_id]);

    data->dgamma{{sp}}_dT[i] = data->g_dgamma{{sp}}_dT[bin_id] +
        data->Tdef[i] * (data->g_dgamma{{sp}}_dT[bin_id+1] 
        - data->g_dgamma{{sp}}_dT[bin_id]);
    {% endfor %}
       
    }

{% endblock interpolate_gamma%}


{% block ensure_electron_consistency %}

void ensure_electron_consistency(double *input, int nstrip, int nchem)
{
    int i, j;

    /* Now we set up some temporaries */
    {%- for species in network.required_species | sort %}
    double {{species.name}};
    {%- endfor %}
    double total_e = 0.0;
    int e_indx;
    
    double scale;

    for (i = 0; i<nstrip; i++) {
        j = i * nchem;
    {%- for species in network.required_species | sort %}
        {{species.name}} = input[j];
        {%if species.name != "ge" and species.name != "de" 
             and species.name != "us_e_0" %}
        total_e += {{species.name}} * {{species.free_electrons}};
        {%-endif%}
        {%if species.name == "de" or species.name == "us_e_0" -%}
        e_indx = j;
        {%endif%}
        j++;
    {% endfor %}
        input[e_indx] = total_e;
    }  
}

{% endblock %}

{% block temperature_from_mass_density %}
void temperature_from_mass_density(double *input, int nstrip,
                                   int nchem, double *strip_temperature)
{
    int i, j;
    double density;
    double kb = 1.3806504e-16; // Boltzmann constant [erg/K]
    double mh = 1.67e-24;
    double gamma = 5.e0/3.e0;
    {% if 'H2_1' in network.species_list() %}
    double gammaH2 = 7.e0/5.e0; // Should be a function of temperature
    	   	     		// this is a temporary solution
    
    double T =  1000.0; // THIS IS TEMPORARY!!! DELTETE!!

    {% endif %}
    {%- for species in network.required_species | sort %}
    double {{species.name}};
    {%- endfor %}
    
    double scale;

    for (i = 0; i<nstrip; i++) {
        j = i * nchem;
    {%- for species in network.required_species | sort %}
        {{species.name}} = input[j];
        {%if species.name != "ge" %}
        {{species.name}} /= {{species.weight}} * mh;
        {%endif%}
        /*fprintf(stderr, "{{species.name}}[%d] = % 0.16g\n",
                i, {{species.name}});*/
        j++;
    {% endfor %}
        density = {{network.print_mass_density()}};
        strip_temperature[i] = {{ network.temperature_calculation() }};
        if (strip_temperature[i] < 1.0)
            strip_temperature[i] = 1.0;
    }
         
}
{% endblock %} {# temperature_from_mass_density #}

{% block calculate_jacobian_sundials %}
int calculate_jacobian_{{solver_name}}
                                        ( realtype t,
                                        N_Vector y, N_Vector fy,
                                        SUNMatrix J, void *user_data,
                                        N_Vector tmp1, N_Vector tmp2,
                                        N_Vector tmp3)
{
    /* We iterate over all of the rates */
    /* Calcuate temperature first */
    
    int nstrip = 1;
    int nchem = {{network.required_species | length }};

    {{solver_name}}_data *data = ({{solver_name}}_data*)user_data; 
    

    int i, j;
    j = 0;
    /* change N_Vector back to an array */
    double y_arr[ {{network.required_species | length }} ];
    {%- for species in network.required_species | sort %}
    y_arr[{{loop.index0}}] = NV_Ith_S(y , {{loop.index0}});
    {%- endfor %}

    {{solver_name}}_calculate_temperature(data, y_arr, nstrip, nchem);
    {{solver_name}}_interpolate_rates(data, nstrip);

    /* Now We set up some temporaries */

    double *T{{ network.energy_term.name }} = data->dTs_{{network.energy_term.name }};

    {%- for name, rate in network.reactions | dictsort %}
    double *{{name}} = data->rs_{{name}};
    double *r{{name}} = data->drs_{{name}};
    {%- endfor %}

    {%- for name, rate in network.cooling_actions | dictsort %}
    {%- for name2 in rate.tables | sort %}
    double *{{name}}_{{name2}} = data->cs_{{name}}_{{name2}};
    double *r{{name}}_{{name2}} = data->dcs_{{name}}_{{name2}};
    {%- endfor %}
    {%- endfor %}

    {%- for species in network.required_species | sort %}
    double {{species.name}};
    {%- endfor %}
    double z;
    double T;

    double mh = 1.67e-24;
    double mdensity, inv_mdensity; 
    int jj;
    jj = 0;
    double scale, scale1, scale2;
    double inv_scale2; 
    int omp_get_thread_num();
    int threadID = omp_get_thread_num();
    
    i = threadID;
    j = 0;
        
    mdensity = 0.0;
    z = data->current_z;
        
    {%- for species in network.required_species | sort %}
    scale = data->scale[threadID][j];
    {{species.name}} = NV_Ith_S( y, {{loop.index0 }}  )*scale;
    //fprintf(stderr,"from jac: {{species.name}} = %.3g\n, Ith(y{{loop.index}}) = %.3g \n" , {{species.name}}, Ith(y,{{loop.index}} ) );
    {%if species.name != "ge" and species.name != "de" and species.name != "us_e_0" %}
    mdensity += {{species.name}} * {{species.weight}};
    {% endif %}
    
    j++;
    {% endfor %}

    mdensity *= mh;
    inv_mdensity = 1.0/mdensity;


    {%- for s1 in network.required_species | sort %}
    //
    // Species: {{s1.name}}
    //
    {% set i_s1 = loop %}
    {%- for s2 in network.required_species | sort %}
    // {{s2.name}} by {{s1.name}}
    {% set i_s2 = loop%}
    {{ network.print_jacobian_component(s2, s1, assign_to="IJth(J, {0}, {1} )".format( i_s2.index, i_s1.index) ) }}
        
    scale2 = data->scale[threadID][{{i_s2.index0}}];
    scale1 = data->scale[threadID][{{i_s1.index0}}];
        
    IJth(J, {{i_s2.index}}, {{i_s1.index}}) /= scale2/scale1;

    {% if s2.name == 'ge' %}
    IJth(J, {{i_s2.index}}, {{i_s1.index}} ) *= inv_mdensity;
    {% endif %}

    {% if s1.name == 'ge' %}
    IJth(J, {{i_s2.index}}, {{i_s1.index}} ) *= T{{network.energy_term.name}}[i];
    {% endif %}
    {%- endfor %}
    {% endfor %}
    
    return 0;
}


{% endblock %}


{% block calcuate_rhs_sundials%}
int calculate_rhs_{{solver_name}}(realtype t, N_Vector y, N_Vector ydot, void *user_data)
{
    {{solver_name}}_data *data = ({{solver_name}}_data* ) user_data;
    int i, j;

    int nchem = {{network.required_species | length }};
    int nstrip = 1;
    
    // change N_Vector back to an array 
    double y_arr[ {{network.required_species | length }} ];
    {%- for species in network.required_species | sort %}
    // the variable is ALREADY scaled in "calculate temperature"
    y_arr[{{loop.index0}}] = NV_Ith_S(y , {{loop.index0 }});
    // fprintf(stderr, "scale: %.3g \n", data->scale[{{loop.index - 1}}]);
    {%- endfor %}

    {{solver_name}}_calculate_temperature(data, y_arr , nstrip, nchem );
    {{solver_name}}_interpolate_rates(data, nstrip);


    // Now we set up some temporaries

    {%- for name, rate in network.reactions | dictsort %}
    double *{{name}} = data->rs_{{name}};
    {%- endfor %}

    {%- for name, rate in network.cooling_actions | dictsort %}
    {%- for name2 in rate.tables | sort %}
    double *{{name}}_{{name2}} = data->cs_{{name}}_{{name2}};
    {%- endfor %}
    {%- endfor %}

    {%- for species in network.required_species | sort %}
    double {{species.name}};
    {%- endfor %}

    double z;
    double T;

    double mh = 1.67e-24;
    double mdensity, inv_mdensity;

    int threadID = omp_get_thread_num();
    i = threadID;
    
    T = data->Ts[i];
    z = data->current_z;
    
    double scale, inv_scale;
    j =0;
    {%- for species in network.required_species | sort %}
    scale = data->scale[threadID][j];
    {{species.name}} = NV_Ith_S( y,{{loop.index0 }} )*scale;
    j++;
    {% if species.name != "ge" and species.name != "de" and species.name != "us_e_0" %}
    mdensity += {{species.name}} * {{species.weight}};
    {% endif %}
    {% endfor %}
    
    mdensity *= mh;
    inv_mdensity = 1.0 / mdensity;

    {%- for species in network.required_species | sort %}
    //
    // Species: {{species.name}}
    //
    {{network.print_ccode(species, assign_to="NV_Ith_S(ydot, {})".format(loop.index0) ) }}
 
    inv_scale = data->inv_scale[threadID][{{loop.index0}}];
    NV_Ith_S(ydot, {{loop.index0}}) *= inv_scale;

    {% if species.name == "ge" %}
    NV_Ith_S(ydot, {{loop.index0}}) *= inv_mdensity;
    {% endif %}
    {% endfor %}
    // fprintf(stderr, "k22: %0.5g, T: %0.5g \n", k22[i], T);
    return 0;
    }
{% endblock %}






{% block read_init_data_to_dengo %}

int read_init_data_to_dengo( dengo_field_data *field_data ){

    // this reads the initial abundances of the data from
    // a hdf5 file, and initialize a field_data object

    char const *filename;
    filename = "{{solver_name}}_initial_conditions.h5";

    hid_t file_id = H5Fopen(filename, H5F_ACC_RDONLY, H5P_DEFAULT);

    if (file_id < 0){
        fprintf(stderr, "failed to open %s so dying. \n", filename);
        return (1);
        }

    hsize_t dims;


    /* Check gas energy to get the number of cells */
    fprintf(stderr, "Getting dimensionality from ge:\n");
    herr_t status = H5LTget_dataset_info(file_id, "/ge", &dims, NULL, NULL);
    if(status == -1) {
        fprintf(stderr, "Error opening initial conditions file.\n");
        return 1;
    }
    fprintf(stderr, "  ncells = % 3i\n", (int) dims);
    
    field_data->ncells = (int) dims;

    int N = {{network.required_species | length }};
    

    double *atol, *rtol;
    atol = (double *) malloc(N * dims * sizeof(double));
    rtol = (double *) malloc(N * dims * sizeof(double));

    double *tics = (double *) malloc(dims * sizeof(double));
    double *ics = (double *) malloc(dims * N * sizeof(double));
    double *input = (double *) malloc(dims * N * sizeof(double));
    
    unsigned int i = 0, j;

    {%- for species in network.required_species | sort %}
    double *{{species.name}} = (double *) malloc(dims * sizeof(double));    
    field_data->{{species.name}}_density = {{species.name}};
    {% endfor %}

    {%- for species in network.required_species | sort %}
    fprintf(stderr, "Reading I.C. for /{{species.name}}\n");
    H5LTread_dataset_double(file_id, "/{{species.name}}", tics);
    for ( j = 0; j < dims; j++ ){
        field_data->{{species.name}}_density[j] = tics[j];
        if (j == 0){
            fprintf(stderr, "{{species.name}}[0] = %0.3g \n", tics[j] );
        }
    }
    i++;
    {% endfor %}
    
    H5Fclose(file_id);
    free(input);
    free(atol);
    free(rtol);
    free(ics);
    
    return 1;

}
{% endblock %} {# read_init_data_to_dengo  #}


{% block write_dengo_data_to_file %}
int write_dengo_data_to_file( dengo_field_data *field_data ){

    int i,j;

    hid_t file_id = H5Fcreate("{{solver_name}}_solution.h5", H5F_ACC_TRUNC, H5P_DEFAULT, H5P_DEFAULT);
    if (file_id < 0){
        fprintf(stderr, "failed to open %s so dying. \n", "{{solver_name}}_solution.h5");
    }
    
    int dims = field_data->ncells;
    
    hsize_t dimsarr[1];
    dimsarr[0] = dims;

    i = 0;
    j = 0;

    {%- for species in network.required_species | sort %}
    double {{species.name}}[dims];
    for ( j = 0; j < dims; j++ ){
        {{species.name}}[j] = field_data->{{species.name}}_density[j];
            
    }
    H5LTmake_dataset_double(file_id, "/{{species.name}}",1,dimsarr, {{species.name}});
    i++;
    {% endfor %}
    
    H5Fclose(file_id);
    
    return 0;
}
{% endblock write_dengo_data_to_file%}






{% block field_data_evolution %}

double dengo_evolve_{{solver_name}}_field_data (double dtf, double &dt, double z, dengo_field_data *field_data,
            double rtol, double abstol, long long dims, {{solver_name}}_data *data) {
    int i, j;
    /* fprintf(stderr, "  ncells = % 3i\n", (int) dims); */

    int N = {{network.required_species | length}};


    if (dt < 0) dt = dtf / 1e0;
    data->current_z = z;
    int niter = 0;
    int siter = 0;

    // Initialize a CVODE object, memory space for EACH THREAD
    // and attach rhs, jac to them respectively.

    int flag;
    void *cvode_mem;
    int MAX_ITERATION = 100;
    double y[10]; // pass answer back from the solver
    double floor_value = 1e-25;
    
    // cvode objects
    SUNLinearSolver LS;
    SUNMatrix A;
    N_Vector y_vec;
    
    y_vec = NULL;
    LS    = NULL;
    A     = NULL;

    y_vec = N_VNew_Serial(N);
    for (i=0; i<N; i++) {
        NV_Ith_S(y_vec,i)   = 1.0;
        y[i] = 1.0;
    }
    
    // these objects should be initialize once !!
    // in each separate thread!!

    rhs_f f = calculate_rhs_{{solver_name}};
    jac_f jf = calculate_jacobian_{{solver_name}};



    double *internal_dt = (double *) malloc(dims * sizeof(double));
    double *ttot = (double *) malloc(dims * sizeof(double));
    int d;
    int sum;
    

    int omp_get_thread_num();
    int threadID;

    #pragma omp parallel private (A, LS, cvode_mem, threadID, y_vec)
    {
        y_vec = NULL;
        y_vec = N_VNew_Serial(N);
        for ( i = 0; i < N; i++){
            NV_Ith_S(y_vec , i) = 1.0;
            y[i]                = 1.0;
            
        }
    A = SUNDenseMatrix(N, N);
    LS = SUNDenseLinearSolver(y_vec, A);
    cvode_mem = setup_cvode_solver( f, jf, abstol, N, data, LS, A, y_vec);

    #pragma omp for private (sum, i, j, d, siter, y)
    for (int d = 0; d < dims; d++){
        
        threadID = omp_get_thread_num();
        // copy array which can be passed to the solver
        
        j = 0;
        {%- for species in network.required_species | sort %}
        // Species: {{species.name}}
        data->scale    [threadID][j] = field_data->{{species.name}}_density[d]/ {{species.weight}};
        data->inv_scale[threadID][j] = 1.0/ data->scale[threadID][j];
        j++;
        {%endfor%}

        // initialize a dt for the solver    
        internal_dt[d] = dt;
        ttot[d]        = 0.0;
        siter          = 0;
            
        while (ttot[d] < dtf) { 
            flag = cvode_solver( cvode_mem, y, N, &internal_dt[d], data, y_vec);
            
            fprintf(stderr, "%d th strip: %d iterations, internal_dt : %0.5g\n", d, siter, internal_dt[d] );

            for (i = 0; i < N; i++) {
                if (y[i] < 0) {
                    flag = 1;
                    break;
                }
            }

            if (flag < 1){
                for (i = 0; i < N; i++){
                    data->scale[threadID][i] = y[i] * data->scale[threadID][i];
                    data->inv_scale[threadID][i] = 1.0/ data->scale[threadID][i];
                    fprintf(stderr , "data->scale[%d] = %0.5g \n", i,y[i]);
                }

                ttot[d] += internal_dt[d];

            } else{
                internal_dt[d] /= 2.0;
            }

	        internal_dt[d] = DMIN(internal_dt[d] * 1.1, dtf - ttot[d] );

            if (siter == MAX_ITERATION) break;

        
            siter++;
        } // while loop for each strip
        
        j = 0;
        // copy results back to the field_data
        // maynot be in the same time instances!!!!
        {%- for species in network.required_species | sort %}
        // Species: {{species.name}}
        field_data->{{species.name}}_density[d] = {{species.weight}} * data->scale[threadID][j];
        j ++;
        {% endfor %}

        fprintf(stderr, "%d the strip = %0.5g\n", d, ttot[d]);

    } // for d dims loop
    
    
    CVodeFree(&cvode_mem);
    SUNLinSolFree(LS);
    SUNMatDestroy(A);
    N_VDestroy(y_vec);
    
    }



    double min_dt = dtf;
    for (d = 0; d < dims; d++){
        if (ttot[d] < min_dt) {
            min_dt = ttot[d];
        }
    }
    free(ttot);
    free(internal_dt);
    return min_dt;
}
{% endblock %} {# field_data_evolution #}

