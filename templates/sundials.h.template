/*

The generalized rate data type holders.

*/
{% block includes %}

/* stdlib, hdf5, local includes */

#include "time.h"
#include "sys/time.h"
#include "stdlib.h"
#include "math.h"
#include "hdf5.h"
#include "hdf5_hl.h"
#include "stdio.h"
#include "string.h"

/* header files for CVODES/SUNDIALS */
#include <cvodes/cvodes.h>           /* prototypes for CVODE fcts. and consts. */
#include <nvector/nvector_serial.h>  /* serial N_Vector types, fcts., and macros */
#include <cvodes/cvodes_dense.h>     /* prototype for CVDense */
#include <sundials/sundials_dense.h> /* definitions DlsMat DENSE_ELEM */
#include <sundials/sundials_types.h> /* definition of type realtype */


/* User-defined vector and matrix accessor macros: Ith, IJth */

/* These macros are defined in order to write code which exactly matches
   the mathematical problem description given above.

   Ith(v,i) references the ith component of the vector v, where i is in
   the range [1..NEQ] and NEQ is defined below. The Ith macro is defined
   using the N_VIth macro in nvector.h. N_VIth numbers the components of
   a vector starting from 0.

   IJth(A,i,j) references the (i,j)th element of the dense matrix A, where
   i and j are in the range [1..NEQ]. The IJth macro is defined using the
   DENSE_ELEM macro in dense.h. DENSE_ELEM numbers rows and columns of a
   dense matrix starting from 0. */

#define Ith(v,i)    NV_Ith_S(v,i-1)       /* Ith numbers components 1..NEQ */
#define IJth(A,i,j) DENSE_ELEM(A,i-1,j-1) /* IJth numbers rows,cols 1..NEQ */



#define MAX_NCELLS 1024
#define NSPECIES {{network.required_species | length}}
#define DMAX(A,B) ((A) > (B) ? (A) : (B))
#define DMIN(A,B) ((A) < (B) ? (A) : (B))

{% endblock %} {# includes #}

int {{solver_name}}_main(int argc, char **argv);

{% block data_structs_for_rates %}

typedef struct {{ solver_name }}_data_ {
    /* All of the network bins will be the same width */
    double dbin;
    double idbin;
    double bounds[2];
    int nbins;

    /* These will be for bins in redshift space */
    double d_zbin;
    double id_zbin;
    double z_bounds[2];
    int n_zbins;

    /* For storing and passing around
       redshift information */
    double current_z;
    double zdef;
    double dz;

    double Ts[MAX_NCELLS];
    double Tdef[MAX_NCELLS]; /* t1, t2, tdef */
    double dT[MAX_NCELLS]; /* t1, t2, tdef */
    double logTs[MAX_NCELLS];
    double invTs[MAX_NCELLS];
    double dTs_{{ network.energy_term.name }}[MAX_NCELLS];

    /* Now we do all of our cooling and chemical tables */
    {%- for name, rate in network.reactions | dictsort %}
    {% if 'pi' not in name -%}
    double r_{{name}}[{{ network.T | length }}];
    double rs_{{name}}[MAX_NCELLS];
    double drs_{{name}}[MAX_NCELLS];
    {%- else -%}
    double r_{{name}}[{{ network.z | length }}];
    double rs_{{name}}[MAX_NCELLS];
    double drs_{{name}}[MAX_NCELLS];
    {%- endif %}
    {% endfor %}
    {%- for name, rate in network.cooling_actions | dictsort %}
    {%- for name2 in rate.tables | sort %}
    {% if 'ph' not in name -%}
    double c_{{name}}_{{name2}}[{{ network.T | length }}];
    double cs_{{name}}_{{name2}}[MAX_NCELLS];
    double dcs_{{name}}_{{name2}}[MAX_NCELLS];
    {%- else -%}
    double c_{{name}}_{{name2}}[{{ network.z | length }}];
    double cs_{{name}}_{{name2}}[MAX_NCELLS];
    double dcs_{{name}}_{{name2}}[MAX_NCELLS];
    {%- endif %}
    {%- endfor %}
    {% endfor %}
    int bin_id[MAX_NCELLS];
    int ncells;
} {{ solver_name }}_data;

{{solver_name}}_data *{{solver_name}}_setup_data(int *, char***);
void {{ solver_name }}_read_rate_tables({{solver_name}}_data*);
void {{ solver_name }}_read_cooling_tables({{solver_name}}_data*);
double dengo_evolve_{{solver_name}} (double dtf, double &dt, double z,
                                     double *input, double *rtol,
                                     double *atol, long long dims,
                                     {{solver_name}}_data *data);
{% endblock %} {# data_struct_for_rates #}


/* Declare ctype RHS and Jacobian */
typedef int(*rhs_f)( realtype, N_Vector , N_Vector , void * );
typedef int(*jac_f)( long int, realtype, N_Vector  , N_Vector , DlsMat , void *, N_Vector, N_Vector, N_Vector);


{% block function_declarations %}

int cvodes_main_solver( rhs_f f, jac_f jac, 
                 double *input, double *rtol, double *atol,
                 int nchem, void *sdata, double t0, double t1);


int calculate_jacobian_{{solver_name}}(long int N, realtype t,
               N_Vector y, N_Vector fy, DlsMat J, void *user_data,
               N_Vector tmp1, N_Vector tmp2, N_Vector tmp3);

int calculate_rhs_{{solver_name}}(realtype t, N_Vector y, N_Vector ydot, void *user_data);
void ensure_electron_consistency(double *input, int nstrip, int nchem);
void temperature_from_mass_density(double *input, int nstrip, int nchem, 
                                   double *strip_temperature);

{% endblock %}


