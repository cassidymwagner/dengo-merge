{% block solver_comment_header %}
/* THIS FILE HAS BEEN AUTO-GENERATED.  DO NOT EDIT. */

/* This is C++ code to read HDF5 files for
   reaction rates, cooling rates, and initial
   conditions for the chemical network defined
   by the user.  In addition, this contains
   code for calculating temperature from the
   gas energy and computing the RHS and the
   Jacobian of the system of equations which
   will be fed into the solver.
*/
{% endblock %}

{% block includes %}

/* stdlib, hdf5, local includes */

#include "time.h"
#include "sys/time.h"
#include "stdlib.h"
#include "math.h"
#include "hdf5.h"
#include "hdf5_hl.h"
#include "stdio.h"

#define MAX_NCELLS 1024

typedef int(*rhs_f)(double *, double *, int, int, void *);
typedef int(*jac_f)(double *, double *, int, int, void *);
int BE_chem_solve(rhs_f f, jac_f J, double *u, double dt, double *rtol, 
                  double *atol, int nstrip, int nchem, void *sdata);

{% endblock %} {# includes #}

{% block data_structs_for_rates %}

typedef struct {{ solver_name }}_data_ {

    /* All of the network bins will be the same width */
    double dbin;
    double idbin;
    double bounds[2];
    int nbins;

    double Ts[MAX_NCELLS];
    double Tdef[MAX_NCELLS]; /* t1, t2, tdef */
    double dT[MAX_NCELLS]; /* t1, t2, tdef */
    double logTs[MAX_NCELLS];
    double dTs_{{ network.energy_term.name }}[MAX_NCELLS];
    /* Now we do all of our cooling and chemical tables */
    {%- for name, rate in network.reactions | dictsort %}
    double r_{{name}}[{{ network.T | length }}];
    double rs_{{name}}[MAX_NCELLS];
    double drs_{{name}}[MAX_NCELLS];
    {% endfor %}
    {%- for name, rate in network.cooling_actions | dictsort %}
    {%- for name2 in rate.tables | sort %}
    double c_{{name}}_{{name2}}[{{ network.T | length }}];
    double cs_{{name}}_{{name2}}[MAX_NCELLS];
    double dcs_{{name}}_{{name2}}[MAX_NCELLS];
    {% endfor %}
    {% endfor %}
    int bin_id[MAX_NCELLS];
    int ncells;
} {{ solver_name }}_data;

void {{ solver_name }}_read_rate_tables({{solver_name}}_data*);
void {{ solver_name }}_read_cooling_tables({{solver_name}}_data*);
{% endblock %} {# data_struct_for_rates #}

{% block function_declarations %}

int calculate_jacobian_{{solver_name}}(double *input, double *Joutput,
        int nstrip, int nchem, void *sdata);
int calculate_rhs_{{solver_name}}(double *input, double *rhs, int nstrip,
                  int nchem, void *sdata);

{% endblock %} {# function_declarations #}

{% block entry_point %}
int main(int argc, char** argv)
{
    {{ solver_name }}_data *data;

    data = ({{solver_name}}_data *) malloc(sizeof({{solver_name}}_data));

    data->bounds[0] = {{ network.T_bounds[0] }};
    data->bounds[1] = {{ network.T_bounds[1] }};
    data->nbins = {{ network.T | length }};
    data->dbin = (log(data->bounds[1]) - log(data->bounds[0])) / data->nbins;
    data->idbin = 1.0L / data->dbin;
    
    {{ solver_name }}_read_rate_tables(data);
    fprintf(stderr, "Successfully read in rate tables.\n");

    {{ solver_name }}_read_cooling_tables(data);
    fprintf(stderr, "Successfully read in cooling rate tables.\n");

    /* Initial conditions */

    hid_t file_id = H5Fopen("{{ solver_name }}_initial_conditions.h5", H5F_ACC_RDONLY, H5P_DEFAULT);
    if (file_id < 0) {fprintf(stderr, "Failed to open "
        "{{ solver_name }}_initial_conditions.h5 so dying.\n");
        return(1);}

    /* Allocate the correct number of cells */
    hsize_t dims; /* We have flat versus number of species */

    /* Check gas energy to get the number of cells */
    fprintf(stderr, "Getting dimensionality from {{ network.energy_term.name }}:\n");
    herr_t status = H5LTget_dataset_info(file_id, "/{{ network.energy_term.name }}", &dims, NULL, NULL);
    fprintf(stderr, "  ncells = % 3i\n", (int) dims);
    data->ncells = dims;

    double atol[{{network.required_species | length}}];
    double rtol[{{network.required_species | length}}];

    int N = {{network.required_species | length}};
    double *tics = (double *) alloca(dims * sizeof(double));
    double *ics = (double *) alloca(dims * N * sizeof(double));
    int i = 0, j;
    {% for s in network.required_species | sort %}
    atol[i] = 1.0;
    rtol[i] = 1e-7;
    fprintf(stderr, "Reading I.C. for /{{ s.name }}\n");
    H5LTread_dataset_double(file_id, "/{{ s.name }}", tics);
    for (j = 0; j < dims; j++) {
        ics[j * N + i] = tics[j];
        if(j==0) {
            fprintf(stderr, "{{s.name}}[0] = %0.3g\n", tics[j]);
        }
    }
    i++;
    {% endfor %}

    H5Fclose(file_id);

    float dt = 1e0;
    rhs_f f = calculate_rhs_{{solver_name}};
    jac_f jf = calculate_jacobian_{{solver_name}};
    int rv = BE_chem_solve(f, jf, ics, dt, rtol, atol, dims, N, (void *) data);
    fprintf(stderr, "Return value: %i\n", rv);
}
{% endblock %} {# entry_point #}

{% block read_tables %}
void {{ solver_name }}_read_rate_tables({{solver_name}}_data *data)
{
    herr_t status;
    hid_t file_id = H5Fopen("{{ solver_name }}_rate_tables.h5", H5F_ACC_RDONLY, H5P_DEFAULT);
    /* Allocate the correct number of rate tables */
    hsize_t dims;

    {%- for name, rate in network.reactions | dictsort %}
    H5LTread_dataset_double(file_id, "/{{ name }}", data->r_{{name}});
    {%- endfor %}

    H5Fclose(file_id);
}

void {{ solver_name }}_read_cooling_tables({{solver_name}}_data *data)
{

    herr_t status;
    hid_t file_id = H5Fopen("{{ solver_name }}_cooling_tables.h5", H5F_ACC_RDONLY, H5P_DEFAULT);
    /* Allocate the correct number of rate tables */
    hsize_t dims;

    {%- for name, rate in network.cooling_actions | dictsort %}
    {%- for name2 in rate.tables | sort %}
    H5LTread_dataset_double(file_id, "/{{name}}_{{name2}}",
                            data->c_{{name}}_{{name2}});
    {%- endfor %}
    {%- endfor %}

    H5Fclose(file_id);
}

{% endblock %} {# read_tables #}

{% block calculate_temperature %}
void {{ solver_name }}_calculate_temperature({{ solver_name }}_data *data,
                        double *input, int nstrip, int nchem)
{
    int i, j;
    double density;
    double kb = 1.3806504e-16; // Boltzmann constant [erg/K]
    double gamma = 5.e0/3.e0;
    {% if 'H2I' in network.species_list() %}
    double gammaH2 = 7.e0/5.e0; // Should be a function of temperature
    	   	     		// this is a temporary solution
    {% endif %}
    double temperature;
    /* Calculate total density */

    {%- for species in network.required_species | sort %}
    double {{species.name}};
    {%- endfor %}

    for (i = 0; i<nstrip; i++) {
        j = i * nchem;
    {%- for species in network.required_species | sort %}
        {{species.name}} = input[j];
        j++;
    {% endfor %}
        density = {{network.print_mass_density()}};
        data->Ts[i] = {{ network.temperature_calculation() }} * 1.67e-24;
        data->logTs[i] = log(data->Ts[i]);
	data->dTs_{{ network.energy_term.name }}[i] = 
        {{ network.temperature_calculation(derivative=True) }};
        fprintf(stderr, "T[%d] = %0.5g\n", i, data->Ts[i]);
    }
         
}
{% endblock %} {# calculate_temperature #}

{% block interpolate_rates %}
/*
   This setup may be different than the user may anticipate, as a result
   of the lockstep timestep we use for a pencil beam through the grid.
   As such, it accepts the number of things to interpolate and makes
   assumptions about the sizes of the rates.
*/

/* This also requires no templating other than for the solver name...*/
void {{ solver_name }}_interpolate_rates({{ solver_name }}_data *data,
                    int nstrip)
{
    int i, ri, bin_id;
    static int ncalls = 0;
    double dd, bv, dy, lb, ub;
    double t1, t2, tdef;
    lb = log(data->bounds[0]);
    ub = log(data->bounds[1]);
    fprintf(stderr, "lb = %0.5g, ub = %0.5g\n", lb, ub);
    for (i = 0; i < nstrip; i++) {
        data->bin_id[i] = bin_id = (int) (data->idbin * (data->logTs[i] - lb));
        t1 = (lb + (bin_id - 1) * data->dbin);
        t2 = (lb + (bin_id    ) * data->dbin);
        data->Tdef[i] = (data->logTs[i] - t1)/(t2 - t1);
        data->dT[i] = (t2 - t1);
        fprintf(stderr, "INTERP: %d, bin_id = %d, dT = %0.5g, T = %0.5g, logT = %0.5g\n",
                i, data->bin_id[i], data->dT[i], data->Ts[i], data->logTs[i]);
    }

    {%- for name, rate in network.reactions | dictsort %}
    for (i = 0; i < nstrip; i++) {
        bin_id = data->bin_id[i];
        data->rs_{{name}}[i] = data->r_{{name}}[bin_id] +
            data->Tdef[i] * (data->r_{{name}}[bin_id+1] - data->r_{{name}}[bin_id]);
        data->drs_{{name}}[i] = (data->r_{{name}}[bin_id+1] - data->r_{{name}}[bin_id]);
        data->drs_{{name}}[i] /= data->dT[i];
    }
    {% endfor %}
    {%- for name, rate in network.cooling_actions | dictsort %}
    {%- for name2 in rate.tables | sort %}
    for (i = 0; i < nstrip; i++) {
        bin_id = data->bin_id[i];
        data->cs_{{name}}_{{name2}}[i] = data->c_{{name}}_{{name2}}[bin_id] +
            data->Tdef[i] * (data->c_{{name}}_{{name2}}[bin_id+1] - data->c_{{name}}_{{name2}}[bin_id]);
        data->dcs_{{name}}_{{name2}}[i] = (data->c_{{name}}_{{name2}}[bin_id+1] - data->c_{{name}}_{{name2}}[bin_id]);;
        data->dcs_{{name}}_{{name2}}[i] /= data->dT[i];
    }
    {% endfor %}
    {% endfor %}

}
{% endblock %} {# interpolate_rates #}

{% block calculate_rhs %}

int calculate_rhs_{{solver_name}}(double *input, double *rhs, int nstrip,
                  int nchem, void *sdata)
{
    /* We iterate over all of the rates */
    /* Calculate temperature first */
    {{solver_name}}_data *data = ({{solver_name}}_data*)sdata;
    int i, j;
    {{solver_name}}_calculate_temperature(data, input, nstrip, nchem);

    {{solver_name}}_interpolate_rates(data, nstrip);

    /* Now we set up some temporaries */
    {%- for name, rate in network.reactions | dictsort %}
    double *{{name}} = data->rs_{{name}};
    {%- endfor %}

    {%- for name, rate in network.cooling_actions | dictsort %}
    {%- for name2 in rate.tables | sort %}
    double *{{name}}_{{name2}} = data->cs_{{name}}_{{name2}};
    {%- endfor %}
    {%- endfor %}
    {%- for species in network.required_species | sort %}
    double {{species.name}};
    {%- endfor %}

    for (i = 0; i<nstrip; i++) {
        j = i * nchem;
    {%- for species in network.required_species | sort %}
        {{species.name}} = input[j];
        j++;
    {% endfor %}
        j = i * nchem;
    {%- for species in network.required_species | sort %}
        // 
        // Species: {{species.name}}
        // 
        {{ network.print_ccode(species, assign_to = "rhs[j]") }}
        j++;
    {% endfor %}
    }
    return 0;
}

{% endblock %}

{% block calculate_jacobian %}
int calculate_jacobian_{{solver_name}}(double *input, double *Joutput,
        int nstrip, int nchem, void *sdata)
{
    /* We iterate over all of the rates */
    /* Calculate temperature first */
    {{solver_name}}_data *data = ({{solver_name}}_data*)sdata;

    int i, j;
    {{solver_name}}_calculate_temperature(data, input, nstrip, nchem);

    {{solver_name}}_interpolate_rates(data, nstrip);

    /* Now we set up some temporaries */
    double *T{{ network.energy_term.name }} = data->dTs_{{ network.energy_term.name }};
    {%- for name, rate in network.reactions | dictsort %}
    double *{{name}} = data->rs_{{name}};
    double *r{{name}} = data->drs_{{name}};
    {%- endfor %}

    {%- for name, rate in network.cooling_actions | dictsort %}
    {%- for name2 in rate.tables | sort %}
    double *{{name}}_{{name2}} = data->cs_{{name}}_{{name2}};
    double *r{{name}}_{{name2}} = data->dcs_{{name}}_{{name2}};
    {%- endfor %}
    {%- endfor %}
    {%- for species in network.required_species | sort %}
    double {{species.name}};
    {%- endfor %}

    for (i = 0; i<nstrip; i++) {
        j = i * nchem;
    {%- for species in network.required_species | sort %}
        {{species.name}} = input[j];
        j++;
    {% endfor %}
        j = i * nchem * nchem;
    {%- for s1 in network.required_species | sort %}
        // 
        // Species: {{s1.name }}
        // 
        {%- for s2 in network.required_species | sort %}
            // {{s1.name}} by {{s2.name}}
            {{ network.print_jacobian_component(s1, s2, assign_to="Joutput[j]") }}
	    {% if s2.name == 'ge' %}
            Joutput[j] *= T{{ network.energy_term.name }}[i];
        {% endif %}
            if(Joutput[j] != 0.0) {
                fprintf(stderr, "Joutput[{{s1.name}}][{{s2.name}}][%d] = %0.5g\n",
                    i, Joutput[j]);
            }
            j++;
        {%- endfor %}
    {% endfor %}
    }
    return 0;
    
}
{% endblock %}
