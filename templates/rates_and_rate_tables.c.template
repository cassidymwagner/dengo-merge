{% block solver_comment_header %}
/* THIS FILE HAS BEEN AUTO-GENERATED.  DO NOT EDIT. */

/* This code sets up C++ code to read HDF5 files for
   the oxygen ion reaction rates and the oxygen
   ion-by-ion cooling rates
*/
{% endblock %}

{% block includes %}

/* stdlib, hdf5, local includes */

#include "time.h"
#include "sys/time.h"
#include "stdlib.h"
#include "math.h"
#include "hdf5.h"
#include "hdf5_hl.h"
#include "stdio.h"
#include "rates_and_rate_tables.h"

#define MAX_NCELLS

{% endblock %} {# includes #}

{% block data_structs_for_rates %}

typedef struct {{ solver_name }}_data_ {

    /* All of the network bins will be the same width */
    double dbin;
    double idbin;
    double bounds[2];

    double Ts[MAX_NCELLS];
    double Tdef[MAX_NCELLS]; /* t1, t2, tdef */
    double dT[MAX_NCELLS]; /* t1, t2, tdef */
    double logTs[MAX_NCELLS];
    /* Now we do all of our cooling and chemical tables */
    {%- for name, rate in network.reactions | dictsort %}
    double r_{{name}}[{{ network.T | length }}];
    double rs_{{name}}[MAX_NCELLS];
    double drs_{{name}}[MAX_NCELLS];
    {% endfor %}
    {%- for name, rate in network.cooling_actions | dictsort %}
    {%- for name2 in rate.tables | sort %}
    double c_{{name}}_{{name2}}[{{ network.T | length }}];
    double cs_{{name}}_{{name2}}[MAX_NCELLS];
    double dcs_{{name}}_{{name2}}[MAX_NCELLS];
    {% endfor %}
    {% endfor %}
    int bin_id[MAX_NCELLS];
    int ncells;
} {{ solver_name }}_data;

void {{ solver_name }}_read_rate_tables(*{{solver_name}}_data);
void {{ solver_name }}_read_cooling_tables(*{{solver_name}}_data);
{% endblock %} {# data_struct_for_rates #}

{% block entry_point %}
int main(int argc, char** argv)
{
    {{ solver_name }}_data *data;

    data = ({{solver_name}}_data *) malloc(sizeof({{solver_name}}_data);

    data->bounds[0] = {{ network.T_bounds[0] }};
    data->bounds[1] = {{ network.T_bounds[1] }};
    data->nbins = {{ network.T | length }};
    data->dbin = (log(data->bounds[1]) - log(data->bounds[0])) / data->nbins;
    data->idbin = 1.0L / data->dbin;
    
    my_rates = {{ solver_name }}_read_rate_tables(data);
    fprintf(stderr, "Successfully read in rate tables.\n");

    my_rates = {{ solver_name }}_read_cooling_tables(data);
    fprintf(stderr, "Successfully read in cooling rate tables.\n");

}
{% endblock %} {# entry_point #}

{% block read_tables %}
void {{ solver_name }}_read_rate_tables({{solver_name}}_rate_data *data)
{
    herr_t status;
    hid_t file_id = H5Fopen("{{ solver_name }}_rate_tables.h5", H5F_ACC_RDONLY, H5P_DEFAULT);
    /* Allocate the correct number of rate tables */
    hsize_t dims;

    {%- for name, rate in network.reactions | dictsort %}
    H5LTread_dataset_double(file_id, "/{{ name }}", data->rate_{{name}});
    {%- endfor %}

    H5Fclose(file_id);
}

void {{ solver_name }}_read_cooling_tables({{solver_name}}_rate_data *data)
{

    herr_t status;
    hid_t file_id = H5Fopen("{{ solver_name }}_cooling_tables.h5", H5F_ACC_RDONLY, H5P_DEFAULT);
    /* Allocate the correct number of rate tables */
    hsize_t dims;

    {%- for name, rate in network.cooling_actions | dictsort %}
    {%- for name2 in rate.tables | sort %}
    H5LTread_dataset_double(file_id, "/{{name}}_{{name2}}",
                            data->cool_{{name}}_{{name2}});
    {%- endfor %}
    {%- endfor %}

    H5Fclose(file_id);

    return cooling_rates;
}

{% endblock %} {# read_tables #}

{% block calculate_temperature %}
void {{ solver_name }}_calculate_temperature({{ solver_name }}_rate_data *data)
{
    double kb = 1.3806504e-16; // Boltzmann constant [erg/K]
    double gamma = 5.d0/3.d0;
    {% if 'H2I' in network.species_list() %}
    double gammaH2 = 7.d0/5.d0; // Should be a function of temperature
    	   	     		// this is a temporary solution
    {% endif %}
    double temperature;

    temperature = density*ge /
    		  (kb * ({{ network.gamma_factor() }});
         
}
{% endblock %} {# calculate_temperature #}

{% block interpolate_rates %}
/*
   This setup may be different than the user may anticipate, as a result
   of the lockstep timestep we use for a pencil beam through the grid.
   As such, it accepts the number of things to interpolate and makes
   assumptions about the sizes of the rates.
*/

/* This also requires no templating other than for the solver name...*/
void {{ solver_name }}_interpolate_rates({{ solver_name }}_rate_data *data,
                    int nstrip)
{
    int i, ri, bin_id;
    static int ncalls = 0;
    RateTable *crate;
    double dd, bv, dy, lb, ub;
    double t1, t2, tdef;
    lb = log(data->bounds[0]);
    ub = log(data->bounds[1]);
    for (i = 0; i < nstrip; i++) {
        data->bin_id[i] = bin_id = (int) (data->idbin * (data->logTs[i] - lb));
        t1 = (lb + (bin_id - 1) * data->dbin);
        t2 = (lb + (bin_id    ) * data->dbin);
        data->Tdef[i] = (data->logTs[i] - t1)/(t2 - t1);
        data->dT[i] = (t2 - t1)
    }

        /*fprintf(stderr, "%04i %0.5e %0.5e %0.5e %0.5e\n",
                bin_id, data->logT[i], data->T[i],
                crate->bounds[0], crate->bounds[1]);*/
    }

    {%- for name, rate in network.reactions | dictsort %}
    for (i = 0; i < nstrip; i++) {
        bin_id = data->bin_id[i];
        data->rs_{{name}}[i] = data->r_{{name}}[bin_id] +
            data->Tdef[i] * (data->r_{{name}}[bin_id+1] - data->r_{{name}}[bin_id]);
        data->drs_{{name}}[i] = (data->r_{{name}}[bin_id+1] - data->r_{{name}}[bin_id]);
        data->drs_{{name}}[i] /= data->dT[i];
    }
    {% endfor %}
    {%- for name, rate in network.cooling_actions | dictsort %}
    {%- for name2 in rate.tables | sort %}
    for (i = 0; i < nstrip; i++) {
        bin_id = data->bin_id[i];
        data->cs_{{name}}_{{name2}}[i] = data->c_{{name}}_{{name2}}[bin_id] +
            data->Tdef[i] * (data->c_{{name}}_{{name2}}[bin_id+1] - data->c_{{name}}_{{name2}}[bin_id]);
        data->dcs_{{name}}_{{name2}}[i] = (data->c_{{name}}_{{name2}}[bin_id+1] - data->c_{{name}}_{{name2}}[bin_id]);;
        data->drs_{{name}}[i] /= data->dT[i];
    }
    {% endfor %}
    {% endfor %}

}
{% endblock %} {# interpolate_rates #}

{% block calculate_rhs %}

int calculate_rhs_{{solver_name}}(float *input, float *rhs, int nstrip,
                  int nchem, {{solver_name}}_data *data)
{
    /* We iterate over all of the rates */
    /* Calculate temperature first */
    {{solver_name}}_calculate_temperature(data);

    {{solver_name}}_interpolate_rates(data, nstrip);

    /* Now we set up some temporaries */
    {%- for name, rate in network.reactions | dictsort %}
    double *{{name}} = data->rs_{{name}};
    {%- endfor %}

    {%- for name, rate in network.cooling_actions | dictsort %}
    {%- for name2 in rate.tables | sort %}
    double *{{name}}_{{name2}} = data->cs_{{name}}_{{name2}};
    {%- endfor %}
    {%- endfor %}
    {%- for species in network.required_species | sort %}
    double {{species.name}};
    {%- endfor %}

    for (i = 0; i<nstrip; i++) {
        j = i * nchem;
    {%- for species in network.required_species | sort %}
        {{species.name}} = input[j];
        j++;
    {% endfor %}
        j = i * nchem;
    {%- for species in network.required_species | sort %}
        // 
        // Species: {{species.name}}
        // 
        {{ network.print_ccode(species, assign_to = "rhs[j]") }}
        j++;
    {% endfor %}
    }
    return 0;
}

{% endblock %}

{% block calculate_jacobian %}
int calculate_jacobian_{{solver_name}}(float *input, float *Joutput,
        int nstrip, int nchem, {{solver_name}}_data *data)
{
    /* We iterate over all of the rates */
    /* Calculate temperature first */
    {{solver_name}}_calculate_temperature(data);

    {{solver_name}}_interpolate_rates(data, nstrip);

    /* Now we set up some temporaries */
    {%- for name, rate in network.reactions | dictsort %}
    double *{{name}} = data->rs_{{name}};
    {%- endfor %}

    {%- for name, rate in network.cooling_actions | dictsort %}
    {%- for name2 in rate.tables | sort %}
    double *{{name}}_{{name2}} = data->cs_{{name}}_{{name2}};
    {%- endfor %}
    {%- endfor %}
    {%- for species in network.required_species | sort %}
    double {{species.name}};
    {%- endfor %}

    for (i = 0; i<nstrip; i++) {
        j = i * nchem * nchem;
    {%- for species in network.required_species | sort %}
        {{species.name}} = input[j];
        j++;
    {% endfor %}
        j = i * nchem * nchem;
    {%- for s1 in network.required_species | sort %}
        // 
        // Species: {{s1.name }}
        // 
        {%- for s2 in network.required_species | sort %}
            // {{s1.name}} by {{s2.name}}
            {{ network.print_jacobian_component(s1, s2, assign_to="Joutput[j]") }}
            j++;
        {%- endfor %}
    {% endfor %}
    }
    return 0;
    
}
{% endblock %}
