{# Welcome to the CVODE template for Dengo! #}
/* 
   THIS IS A GENERATED FILE: PLEASE DO NOT EDIT DIRECTLY.
   
   EDIT THE TEMPLATE INSTEAD.
*/

/* CVODE includes */

#include "cvode.h"
#include <nvector/nvector_serial.h>  /* serial N_Vector types, fcts., macros */
#include <cvode/cvode_dense.h>       /* prototype for CVDense */
#include <sundials/sundials_dense.h> /* definitions DlsMat DENSE_ELEM */
#include <sundials/sundials_types.h> /* definition of type realtype */

/* stdlib, hdf5, local includes */

#include "time.h"
#include "sys/time.h"
#include "stdlib.h"
#include "math.h"
#include "H5LT.h"
#include "rates_and_rate_tables.h"

#define CVODE_MAX(A, B) ((A) > (B) ? (A) : (B))
#define CVODE_MIN(A, B) ((A) < (B) ? (A) : (B))
#define CVODE_TINY 1.0e-30
#define CVODE_GAMMA 1.666667
#define CVODE_KB 1.380e-16
#define CVODE_MH 1.67e-24
#define CVODE_PI 3.1415926
#define CVODE_GRAV 6.67e-8

typedef struct {{ solver_name }}_cvode_data {
    int ncells;
    double *T;
    double *rho;
    /* This is probably invalid, as CVODE may rewind */
    double redshift;
    TableOfRates *rate_tables;
    TableOfRates *cooling_tables;
} {{ solver_name }}_cvode_data;

/* These change with the particular reaction rate solver, so we do not
outsource them to a header file. */
TableOfRates *{{ solver_name }}_read_rate_tables();
TableOfRates *{{ solver_name }}_read_cooling_tables();
void {{ solver_name }}_interpolate_rates(double *outputvals,
        double T, TableOfRates *rate_tables);
static int {{ solver_name }}_cvode_calc_derivs(
    realtype t, N_Vector y, N_Vector ydot, void *user_data);
static int {{ solver_name }}_cvode_calc_jacobian
              (int N, int mu, int ml,
               realtype t, N_Vector u, N_Vector fu, 
               DlsMat J, void *user_data,
               N_Vector tmp1, N_Vector tmp2, N_Vector tmp3);
static int check_flag(void *flagvalue, char *funcname, int opt);
int write_vector_to_hdf5(N_Vector y, 
                          {{ solver_name }}_cvode_data *data,
                          realtype t,
                          int final);
double {{ solver_name }}_cvode_compute_temperature(
    {% for sname, s in species_varnames|dictsort %}realtype {{ s }},{% endfor %}
    int cell, {{ solver_name }}_cvode_data *data);

#ifdef SAMPLE_TEST_PROBLEM
int main(int argc, char** argv)
{
    /* Now we run some tests.  This is just equally-spaced interpolation. */
    int i, ri, offset = {{ num_solved_species }};

    {{ solver_name }}_cvode_data data;

    /* INITIAL CONDITIONS */
    /* Note that this will be inefficient, memorywise ... */

    hid_t file_id = H5Fopen("{{ solver_name }}_initial_conditions.h5", H5F_ACC_RDONLY, H5P_DEFAULT);
    if (file_id < 0) {fprintf(stderr, "Failed to open "
        "{{ solver_name }}_initial_conditions.h5 so dying.\n");
        return(1);}
    realtype tfinal;
    H5LTget_attribute_double(file_id, "/", "tfinal", &tfinal);
    /* Allocate the correct number of cells */
    hsize_t dims; /* We have flat versus number of species */

    /* Just look at one to get the number of cells */
    {% set sn = species_varnames.keys()[0] %}
    printf("Getting dimensionality from {{ sn }}:\n");
    herr_t status = H5LTget_dataset_info(file_id, "/{{ sn }}", &dims, NULL, NULL);
    printf("  ncells = % 3i\n", (int) dims);
    data.ncells = dims;
    data.T = (double *) calloc(data.ncells, sizeof(double));
    data.rho = (double *) calloc(data.ncells, sizeof(double));

    TableOfRates *my_rates;
    
    my_rates = {{ solver_name }}_read_rate_tables();
    fprintf(stderr, "Successfully read in rate tables.\n");
    my_rates->nrates = {{ rate_table | length }};
    data.rate_tables = my_rates;

    my_rates = {{ solver_name }}_read_cooling_tables();
    fprintf(stderr, "Successfully read in cooling rate tables.\n");
    my_rates->nrates = {{ cooling_rate_table | length }};
    data.cooling_tables = my_rates;

    /* Create serial vector of length NEQ for I.C. and abstol */
    N_Vector y = NULL;
    y = N_VNew_Serial({{ num_solved_species }} * data.ncells);
    if (check_flag((void *)y, "N_VNew_Serial", 0)) return(1);

    double *values = (double *) calloc(dims, sizeof(double));
    {% for sname, sid in non_eq_species_ids|dictsort %}
    printf("Reading /{{ sname }}\n");
    H5LTread_dataset_double(file_id, "/{{ sname }}", values);
    for (i = 0; i < data.ncells; i++)
    {
        NV_Ith_S(y, i*offset + {{ non_eq_species_ids[sname] }}) = values[i];
        printf("Setting {{ sname }}[%i] = %0.5e\n", i, values[i]);
    }
    {% endfor %}

    printf("Reading /rho\n");
    H5LTread_dataset_double(file_id, "/rho", data.rho);

    H5Fclose(file_id);

    void *user_data = (void *) &data;

    /* Now boilerplate CVODE stuff */
    realtype reltol, t, tout, abstol;
    void *cvode_mem;
    int flag, flagr, iout;

    cvode_mem = NULL;

    /* Set the scalar relative tolerance */
    reltol = 1e-5; abstol = 0.0;

    /* Call CVodeCreate to create the solver memory and specify the 
     * Backward Differentiation Formula and the use of a Newton iteration */
    cvode_mem = CVodeCreate(CV_BDF, CV_NEWTON);
    if (check_flag((void *)cvode_mem, "CVodeCreate", 0)) return(1);

    /* Call CVodeInit to initialize the integrator memory and specify the
     * user's right hand side function in y'=f(t,y), the inital time T0, and
     * the initial dependent variable vector y. */
    flag = CVodeInit(cvode_mem, {{ solver_name }}_cvode_calc_derivs, 0.0, y);
    if (check_flag(&flag, "CVodeInit", 1)) return(1);

    flag = CVodeSetUserData(cvode_mem, user_data);
    if (check_flag(&flag, "CVodeSetUserData", 1)) return(1);

    /* Call CVodeSVtolerances to specify the scalar relative tolerance
     * and vector absolute tolerances */
    flag = CVodeSStolerances(cvode_mem, reltol, abstol);
    if (check_flag(&flag, "CVodeSVtolerances", 1)) return(1);

    flag = CVodeSetMaxNumSteps(cvode_mem, 10000);
    if (check_flag(&flag, "CVodeSetMaxNumSteps", 1)) return(1);

    /* Call CVDense to specify the CVDENSE dense linear solver */
    //flag = CVDiag(cvode_mem);
    flag = CVBand(cvode_mem, data.ncells * {{ num_solved_species }},
        {{ num_solved_species }}-1, {{ num_solved_species }}-1);
    if (check_flag(&flag, "CVDense", 1)) return(1);

    /* Set the user-supplied Jacobian routine Jac */
    //flag = CVDlsSetBandJacFn(cvode_mem, {{ solver_name }}_cvode_calc_jacobian);
    if(check_flag(&flag, "CVDlsSetBandJacFn", 1)) return(1);

    /* In loop, call CVode, print results, and test for error.
       Break out of loop when NOUT preset output times have been reached.  */
    printf(" \n{{ num_total_species }}-species kinetics problem"
            " ({{ num_solved_species}} directly solved)\n\n");

#ifdef SLEEP_AT_START
    fprintf(stderr, "ABOUT TO START: SLEEPING FOR 3 seconds\n");
    sleep(3);
#endif
    iout = 0;  tout = 1e-3;
    double walli, wallf;
    struct timeval tp;

    gettimeofday(&tp, NULL);
    walli = tp.tv_sec + tp.tv_usec*(1e-6);

    if (write_vector_to_hdf5(y, &data, tout, -1)) return (1);

    while(1) {
      printf("Requesting output from CVODE at %0.3e (H2I = %0.5e, HI = %0.5e, T = %0.5e)\n",
             tout,
             NV_Ith_S(y, {{ non_eq_species_ids["H2I"] }}) / data.rho[0],
             NV_Ith_S(y, {{ non_eq_species_ids["HI"] }}) / data.rho[0],
             data.T[0] );
      flag = CVode(cvode_mem, tout, y, &t, CV_NORMAL);

      if (check_flag(&flag, "CVode", 1)) break;
      if (flag == CV_SUCCESS) {
        iout++;
      }

      /* Now we write our output */
      if (write_vector_to_hdf5(y, &data, tout, 0)) return (1);

      if (tout >= tfinal) break;
      tout = CVODE_MIN(tout*1.2, tfinal);
    }

    if (write_vector_to_hdf5(y, &data, 0, 1)) return (1);

    gettimeofday(&tp, NULL);
    wallf = tp.tv_sec + tp.tv_usec*(1e-6);

    printf("Took %0.5e seconds\n", (wallf-walli));
    printf("Final output from CVODE at %0.3e (H2I = %0.5e, HI = %0.5e, T = %0.5e)\n",
        tout,
        NV_Ith_S(y, {{ non_eq_species_ids["H2I"] }}) / data.rho[0],
        NV_Ith_S(y, {{ non_eq_species_ids["HI"] }}) / data.rho[0],
        data.T[0] );

    /* Free y and abstol vectors */
    N_VDestroy_Serial(y);

    /* Free integrator memory */
    CVodeFree(&cvode_mem);

    return(0);
}

int write_vector_to_hdf5(N_Vector y, 
                          {{ solver_name }}_cvode_data *data,
                          realtype t,
                          int final)
{
  static int iter = 0;
  static double *state_vector = NULL;
  static hid_t outfile = -1;
  char dataset_name[255];
  if (final == -1)
  {
    outfile = H5Fcreate("{{solver_name}}_output.h5", 
        H5F_ACC_TRUNC, H5P_DEFAULT, H5P_DEFAULT);
    if (outfile < 0)
    {
      fprintf(stderr, "Failed to open "
          "{{ solver_name }}_output.h5 so dying.\n");
      return(1);
    }

    char *buffer;
    /* Write out our species names */

    H5LTset_attribute_double(outfile, "/", "rho", data->rho, data->ncells);

    {%- for sname, sid in non_eq_species_ids|dictsort %}
    H5LTset_attribute_char(outfile, "/", "{{"%i"|format(sid)}}", "{{sname}}", {{sname | length}});
    {%- endfor %}

    int size = data->ncells * {{ num_solved_species }};
    printf("Constructing state vector of size %i.\n", size);
    state_vector = (double *)malloc(size*sizeof(double));
    return(0);
  }
  else if (final == 1)
  {
    printf("Closing output file.\n");
    H5Fflush(outfile, H5F_SCOPE_GLOBAL);
    H5Fclose(outfile);
    printf("Clearing state vector.\n");
    free(state_vector);
    return(0);
  }
  int i, offset = {{ num_solved_species }};
  for (i = 0; i < data->ncells; i++)
  {
    {%- for s, sid in non_eq_species_ids|dictsort %}
    state_vector[i * offset + {{ sid }}] = NV_Ith_S(y, i * offset + {{ sid }}); /* {{ s }} */
    {%- endfor %}
  }

  hsize_t dims[2] = { data->ncells, {{ num_solved_species }}};

  snprintf(dataset_name, 255, "/%08i", iter++);
  //printf("Writing at t=%0.5e to %s\n", dataset_name);

  H5LTmake_dataset_double(outfile, dataset_name, 2, dims, state_vector);
  H5LTset_attribute_double(outfile, dataset_name, "t", &t, 1);

  return (0);
}

#endif

TableOfRates *{{ solver_name }}_read_rate_tables()
{
    TableOfRates *chemical_rates = 
            (TableOfRates *) malloc(sizeof(TableOfRates));

    herr_t status;
    hid_t file_id = H5Fopen("{{ solver_name }}_rate_tables.h5", H5F_ACC_RDONLY, H5P_DEFAULT);
    /* Allocate the correct number of rate tables */
    hsize_t dims;

    chemical_rates->nrates = {{ rate_table|length }};
    chemical_rates->rates =
            (RateTable *) malloc(sizeof(RateTable) * chemical_rates->nrates);

    int i = 0;

    RateTable *crate;

    {%- for name, rate in rate_table|dictsort %}
    /* Now reading our {{ rate_ids[name] }}-th rate, {{ rate.name }} */
    status = H5LTget_dataset_info(file_id, "/{{ rate.name }}", &dims, NULL, NULL);
    crate = &chemical_rates->rates[{{ rate_ids[name] }}];
    /* Assume log-spaced bins */
    crate->bounds[0] = {{ rate.T_bounds[0] }};
    crate->bounds[1] = {{ rate.T_bounds[1] }};
    crate->nbins = {{ rate.T | length }};
    crate->dbin = (log10(crate->bounds[1]) - log10(crate->bounds[0])) / crate->nbins;
    crate->idbin = 1.0L / crate->dbin;
    crate->values = (double *) malloc(crate->nbins * sizeof(double));
    H5LTread_dataset_double(file_id, "/{{ rate.name }}", crate->values);
    i++;
    {%- endfor %}

    H5Fclose(file_id);

    return chemical_rates;
}

TableOfRates *{{ solver_name }}_read_cooling_tables()
{
    TableOfRates *cooling_rates = 
            (TableOfRates *) malloc(sizeof(TableOfRates));

    herr_t status;
    hid_t file_id = H5Fopen("{{ solver_name }}_cooling_tables.h5", H5F_ACC_RDONLY, H5P_DEFAULT);
    /* Allocate the correct number of rate tables */
    hsize_t dims;

    cooling_rates->nrates = {{ cooling_rate_table|length }};
    cooling_rates->rates =
            (RateTable *) malloc(sizeof(RateTable) * cooling_rates->nrates);

    int i = 0, j;

    RateTable *crate;

    {%- for name, rate in cooling_rate_table|dictsort %}
    /* Now reading our {{ cooling_rate_ids[name] }}-th rate, {{ rate.name }} */
    status = H5LTget_dataset_info(file_id, "/{{ rate.name }}", &dims, NULL, NULL);
    crate = &cooling_rates->rates[{{ cooling_rate_ids[name] }}];
    /* Assume log-spaced bins */
    crate->bounds[0] = {{ rate.T_bounds[0] }};
    crate->bounds[1] = {{ rate.T_bounds[1] }};
    crate->nbins = {{ rate.T | length }};
    crate->dbin = (log10(crate->bounds[1]) - log10(crate->bounds[0])) / crate->nbins;
    crate->idbin = 1.0L / crate->dbin;
    crate->values = (double *) malloc(crate->nbins * sizeof(double));
    H5LTread_dataset_double(file_id, "/{{ rate.name }}", crate->values);
    /*for (j = 0; j < {{ rate.T | length }} ; j++)
        printf("{{ rate.name }}[%i] = %0.5e\n", j, crate->values[j]);*/
    i++;
    {%- endfor %}

    H5Fclose(file_id);

    return cooling_rates;
}

/*
   This setup may be different than the user may anticipate, as a result
   of the lockstep timestep we use for a pencil beam through the grid.
   As such, it accepts the number of things to interpolate and makes
   assumptions about the sizes of the rates.
*/


/* This also requires no templating other than for the solver name...*/
void {{ solver_name }}_interpolate_rates(double outputvals[], double T,
                       TableOfRates *rate_tables)
{
    int i, ri, bin_id;
    static ncalls = 0;
    RateTable *crate;
    double logT = log10(T);
    double dd, bv, dy, lb, ub;

    crate = &rate_tables->rates[0];
    lb = log10(crate->bounds[0]);
    ub = log10(crate->bounds[1]);
    bin_id = (int) (crate->idbin * (logT - lb));
    dd = (logT - (bin_id * crate->dbin + lb))*crate->idbin;
    for (ri = 0; ri < rate_tables->nrates; ri++) {
        crate = &rate_tables->rates[ri];
        /* Our interpolation logic here */
        /* Identify our bin */
        bv = crate->values[bin_id];
        dy = crate->values[bin_id + 1] - bv;
        outputvals[ri] = bv + dd*dy;
        /*fprintf(stdout, "AUGH %i %0.5e %0.5e %0.5e %0.5e\n",
          ri, bin_id, crate->idbin, logT, lb, outputvals[ri]);*/
    }
}

double {{ solver_name }}_cvode_compute_temperature(
    {% for sname, s in species_varnames|dictsort %}realtype {{ s }},
    {% endfor %}
    int cell, {{ solver_name }}_cvode_data *data)
{
  {% block compute_temperature_function %}
#error "You must implement the compute_temperature block, even if it is empty!"
  {% endblock %}
}

static int {{ solver_name }}_cvode_calc_derivs(
    realtype t, N_Vector y, N_Vector ydot, void *user_data)
{
  /* Psuedocode for calculating:
      create variables

      calculate our T
      interpolate our k values at their T 
      for cell in cells:
          for rxn in rxns:
              calculate r from species and k values
          for s in species:
              for rxn in rxns:
                  if s not in rxn.considered: continue
                  ydot(s) += rxn.dot(species)
          calculate cooling
          ydot(ge) += cooling
  */

  int i, cell, offset;
  double T;
  double interpolated_rates[{{ reaction_varnames | length }}];
  double interpolated_cooling_rates[{{ cooling_rate_table | length }}];

  realtype eq_temp_num, eq_temp_den;

  /* We map all of our species to variables:
     {%- for v, vname in species_varnames|dictsort %}
     {{ "% 8s => % 8s" | format(v, vname) }}
     {%- endfor %}
  */
  realtype {% for v in species_varnames.values()|sort %}{{ v }}{%- if not loop.last %}, {% endif %}{% endfor %};

  /* We map all of our reactions to variables:
     {%- for v, vname in reaction_varnames|dictsort %}
     {{ "% 8s => % 8s" | format(v, vname) }}
     {%- endfor %}
  */
  realtype {% for v in reaction_varnames.values()|sort %}{{ v }}{%- if not loop.last %}, {% endif %}{% endfor %};

  /* We calculate our offset between identical species for different cells */
  int species_offset = {{ num_solved_species }};

  /* Now we have our user_data object. */
  {{ solver_name }}_cvode_data *data = ({{ solver_name }}_cvode_data *) user_data;


  for (cell = 0, offset = 0; cell < data->ncells; cell += 1, offset += species_offset)
  {

    /*
      We fundamentally calculate cooling differently than chemical kinetic
      equations, but note that above we also carry our 'species' that is gas
      energy; we simply have no chemical rate equations that depend on it.
    */
    {% for sname, sid in non_eq_species_ids|dictsort %}
    {{ species_varnames[sname] }} = NV_Ith_S(y, offset + {{ sid }});
    {% endfor %}

      T = {{ solver_name }}_cvode_compute_temperature(
        {% for sname, s in species_varnames|dictsort %}{{ s }},
        {% endfor %}
        cell, data);

      {{ solver_name }}_interpolate_rates( interpolated_rates, T, data->rate_tables);
      {{ solver_name }}_interpolate_rates( interpolated_cooling_rates, T, data->cooling_tables);

    {% block apply_constraints %}
#error "You must implement the apply_constraints block, even if it is empty!"
    {% endblock %}

    /*
      EQUILIBRIUM SPECIES
    */

    {% for sname, s in eq_species_table|dictsort %}
    /* Equilibrium species {{ sname }} */

      eq_temp_den = eq_temp_num = 0.0L;

    {%- for rname, rxn in reaction_table|dictsort %}

    {%- if sname in rxn.considered %}
      /* Reaction {{ rname }}
         Which is: {{ rxn }}
      */
     {%- if sname in rxn.up_species %}
       eq_temp_num += interpolated_rates[{{ reaction_ids[rname] }}][cell]
            {%- for n, s1 in rxn.left_side %}{% for i in range(n) %}*{{ species_varnames[s1.name] }}{% endfor %}{% endfor %};
     {%- endif %}
     {%- if sname in rxn.down_species %}
       eq_temp_den += interpolated_rates[{{ reaction_ids[rname] }}][cell]
            {%- for n, s1 in rxn.left_side %}{% if s1.name != sname%}{% for i in range(n) %}*{{ species_varnames[s1.name] }}{% endfor %}{% endif %}{% endfor %};
     {%- endif %}

    {%- endif %}{# s in rxn #}
    {%- endfor %}{# rxn #}

    {{ species_varnames[sname] }} = eq_temp_num / eq_temp_den;
    {{ species_varnames[sname] }} = CVODE_MAX({{- species_varnames[sname] }}, CVODE_TINY);
    /*printf("Equilibrium species {{ sname }}[%i] = %0.5e\n", cell, {{ species_varnames[sname] }});*/

    {% endfor %}{# species #}


    /* RECALCULATE RATES WITH EQUILIBRIUM ABUNDANCES */

    {%- for rname, rxn in reaction_table|dictsort %}  
    /* Calculating reaction value for {{ rxn.name }}
       defined as {{ rxn }}
    */
    {{ reaction_varnames[rname] }} = interpolated_rates[{{ reaction_ids[rname] }}]
        {% for n, s in rxn.left_side %}{% for i in range(n) %}*{{ species_varnames[s.name] }} / {{ s.weight }}{% endfor %}{% endfor %};

    {%- endfor %}

    /* CALCULATE COOLING TERMS */
    realtype edot = 0.0;

    {%- for aname, act in cooling_action_table|dictsort %}
    {% if aname == 'compton' %}{% continue %}{% endif %}
    /* HANDLING {{ aname }} */
    edot += ({{ pp.doprint(act.equation) }});
    /* Derivative: {{ pp.doprint(act.dequation.diff("T")) }} */
    {% endfor %}
    //return(1);

    edot /= CVODE_MH * data->rho[cell];
    NV_Ith_S(ydot, {{ non_eq_species_ids["ge"] }} + offset ) = edot;

    {%- for sname, s in non_eq_species_table|dictsort %}
      {% if sname == "ge" %}{% continue %}{% endif %}
      /*
         Handling species {{ sname }}
      */

      NV_Ith_S(ydot, {{ non_eq_species_ids[sname] }} + offset) = {{ s.weight }} * (0.0 
      {%- for rname, rxn in reaction_table|dictsort %}
        {%- if sname in rxn.considered %}
        /* REACTION: {{ rxn.name }}
           {{ rxn }}
           DOWN: {{ rxn.down_species }}
           UP  : {{ rxn.up_species }} */
          +{{ rxn.net_change(sname)|float }}L * {{ reaction_varnames[rname] }}
        {%- endif %}
      {%- endfor %}
      );
#define {{ solver_name }}_CVODE_DEBUG_OFF
#ifdef {{ solver_name }}_CVODE_DEBUG
    printf("  cell = % 4i species = % 7s val = %0.5e dot = % 0.5e\n",
           cell, "{{ sname }}",
           {{ species_varnames[sname] }},
           NV_Ith_S(ydot, {{ non_eq_species_ids[sname] }} + offset));
#endif

    {%- endfor %}

    {% block end_of_derivatives %}{% endblock %}
    NV_Ith_S(ydot, {{ non_eq_species_ids["ge"] }} + offset ) = edot;


  }

  return (0);

}

static int {{ solver_name }}_cvode_calc_jacobian
              (int N, int mu, int ml,
               realtype t, N_Vector y, N_Vector fy, 
               DlsMat jac, void *user_data,
               N_Vector tmp1, N_Vector tmp2, N_Vector tmp3)
{
  
  int i, cell, offset;
  double T;
  double interpolated_rates[{{ reaction_varnames | length }}];
  double interpolated_cooling_rates[{{ cooling_rate_table | length }}];

  /* We map all of our species to variables:
     {%- for v, vname in species_varnames|dictsort %}
     {{ "% 8s => % 8s" | format(v, vname) }}
     {%- endfor %}
  */
  realtype {% for v in species_varnames.values()|sort %}{{ v }}{%- if not loop.last %}, {% endif %}{% endfor %};

  /* We map all of our reactions to variables:
     {%- for v, vname in reaction_varnames|dictsort %}
     {{ "% 8s => % 8s" | format(v, vname) }}
     {%- endfor %}
  */
  realtype {% for v in reaction_varnames.values()|sort %}{{ v }}{%- if not loop.last %}, {% endif %}{% endfor %};

  /* We calculate our offset between identical species for different cells */
  int species_offset = {{ num_solved_species }};

  /* Now we have our user_data object. */
  {{ solver_name }}_cvode_data *data = ({{ solver_name }}_cvode_data *) user_data;


  for (cell = 0, offset = 0; cell < data->ncells; cell += 1, offset += species_offset)
  {

    {% for sname, sid in non_eq_species_ids|dictsort %}
    {{ species_varnames[sname] }} = NV_Ith_S(y, offset + {{ sid }});
    {% endfor %}

      T = {{ solver_name }}_cvode_compute_temperature(
        {% for sname, s in species_varnames|dictsort %}{{ s }},
        {% endfor %}
        cell, data);

      {{ solver_name }}_interpolate_rates( interpolated_rates, T, data->rate_tables);
      {{ solver_name }}_interpolate_rates( interpolated_cooling_rates, T, data->cooling_tables);

    {%- for sn1, s1 in non_eq_species_table|dictsort %}
      {%- if sn1 == "ge" %}{% continue %}{%- endif %}
      {%- for sn2, s2 in non_eq_species_table|dictsort %}
        {%- if sn2 == "ge" %}{% continue %}{%- endif %}

          /*
             Handling species d{{ sn1 }}'/d{{ sn2 }}
          */

          BAND_ELEM(jac, {{ non_eq_species_ids[sn1] }} + offset,
                         {{ non_eq_species_ids[sn2] }} + offset) =
                   {{ s1.weight }} * (0.0 
          {%- for rname, rxn in reaction_table|dictsort %}
            {%- if sn1 not in rxn.considered %}{% continue %}{%- endif %}
            {%- if sn2 not in rxn.down_species %}{% continue %}{%- endif %}
            /* REACTION: {{ rxn.name }}
               {{ rxn }}
               DOWN: {{ rxn.down_species }}
               UP  : {{ rxn.up_species }} */
            
            +  interpolated_rates[{{reaction_ids[rname]}}] * {{ rxn.net_change(sn1)|float }}L  {# multiplied below #}
            {%- for nchange, s3 in rxn.left_side %}
              {%- if s3.name == sn2 %}{% set niter = nchange - 1 %}
                    * (1.0L/{{s3.weight}})
              {% else %}{% set niter = nchange %}{% endif %}
                {%- for i in range(niter) %}*({{ species_varnames[s3.name] }} / {{ s3.weight }}){% endfor %}
            {%- endfor %}
          {%- endfor %}
            );
        {%- endfor %}
      {%- endfor %}
#define {{ solver_name }}_CVODE_DEBUG_OFF
#ifdef {{ solver_name }}_CVODE_DEBUG
    printf("  cell = % 4i species = % 7s val = %0.5e dot = % 0.5e\n",
           cell, "{{ sname }}",
           {{ species_varnames[sname] }},
           NV_Ith_S(ydot, {{ non_eq_species_ids[sname] }} + offset));
#endif

    }

#if 0
  data = (UserData) user_data;
  hordc = data->hdcoef;
  horac = data->hacoef;
  verdc = data->vdcoef;
  
  for (j=1; j <= MY; j++) {
    for (i=1; i <= MX; i++) {
      k = j-1 + (i-1)*MY;
      kthCol = BAND_COL(J,k);

      /* set the kth column of J */

      BAND_COL_ELEM(kthCol,k,k) = -TWO*(verdc+hordc);
      if (i != 1)  BAND_COL_ELEM(kthCol,k-MY,k) = hordc + horac;
      if (i != MX) BAND_COL_ELEM(kthCol,k+MY,k) = hordc - horac;
      if (j != 1)  BAND_COL_ELEM(kthCol,k-1,k)  = verdc;
      if (j != MY) BAND_COL_ELEM(kthCol,k+1,k)  = verdc;
    }
  }
#endif

  return(0);
}

static int check_flag(void *flagvalue, char *funcname, int opt)
{
  int *errflag;

  /* Check if SUNDIALS function returned NULL pointer - no memory allocated */
  if (opt == 0 && flagvalue == NULL) {
    fprintf(stderr, "\nSUNDIALS_ERROR: %s() failed - returned NULL pointer\n\n",
	    funcname);
    return(1); }

  /* Check if flag < 0 */
  else if (opt == 1) {
    errflag = (int *) flagvalue;
    if (*errflag < 0) {
      fprintf(stderr, "\nSUNDIALS_ERROR: %s() failed with flag = %d\n\n",
	      funcname, *errflag);
      return(1); }}

  /* Check if function returned NULL pointer - no memory allocated */
  else if (opt == 2 && flagvalue == NULL) {
    fprintf(stderr, "\nMEMORY_ERROR: %s() failed - returned NULL pointer\n\n",
	    funcname);
    return(1); }

  return(0);
}
